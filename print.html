<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOTA GoShimmer</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="goshimmer.html"><strong aria-hidden="true">1.</strong> GoShimmer</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">2.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="tutorials.html"><strong aria-hidden="true">3.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/setup.html"><strong aria-hidden="true">3.1.</strong> Setting up a GoShimmer node</a></li><li class="chapter-item expanded "><a href="tutorials/request_funds.html"><strong aria-hidden="true">3.2.</strong> Obtaining tokens from the faucet</a></li><li class="chapter-item expanded "><a href="tutorials/wallet.html"><strong aria-hidden="true">3.3.</strong> The wallet library</a></li><li class="chapter-item expanded "><a href="tutorials/dApp.html"><strong aria-hidden="true">3.4.</strong> Writing a dApp</a></li><li class="chapter-item expanded "><a href="tutorials/syncbeacon.html"><strong aria-hidden="true">3.5.</strong> How to run a sync beacon</a></li><li class="chapter-item expanded "><a href="tutorials/follow_syncbeacon.html"><strong aria-hidden="true">3.6.</strong> How to configure followed sync beacon nodes</a></li><li class="chapter-item expanded "><a href="tutorials/static_identity.html"><strong aria-hidden="true">3.7.</strong> How to create a static identity</a></li><li class="chapter-item expanded "><a href="tutorials/custom_dRNG.html"><strong aria-hidden="true">3.8.</strong> How to setup a custom dRNG committee</a></li><li class="chapter-item expanded "><a href="tutorials/monitoring.html"><strong aria-hidden="true">3.9.</strong> Setting up Monitoring Dashboard</a></li></ol></li><li class="chapter-item expanded "><a href="application_logic.html"><strong aria-hidden="true">4.</strong> Application logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="application_logic/protocol.html"><strong aria-hidden="true">4.1.</strong> Protocol high level overview</a></li></ol></li><li class="chapter-item expanded "><a href="implementation_design.html"><strong aria-hidden="true">5.</strong> Implementation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="implementation_design/event_driven_model.html"><strong aria-hidden="true">5.1.</strong> Event driven model</a></li><li class="chapter-item expanded "><a href="implementation_design/packages_plugins.html"><strong aria-hidden="true">5.2.</strong> Packages and plugins</a></li><li class="chapter-item expanded "><a href="implementation_design/plugin.html"><strong aria-hidden="true">5.3.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="implementation_design/configuration_parameters.html"><strong aria-hidden="true">5.4.</strong> Configuration parameters</a></li><li class="chapter-item expanded "><a href="implementation_design/object_storage.html"><strong aria-hidden="true">5.5.</strong> Object storage</a></li></ol></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">6.</strong> API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apis/api.html"><strong aria-hidden="true">6.1.</strong> Client Lib</a></li><li class="chapter-item expanded "><a href="apis/webAPI.html"><strong aria-hidden="true">6.2.</strong> WebAPI</a></li><li class="chapter-item expanded "><a href="apis/mana.html"><strong aria-hidden="true">6.3.</strong> Mana</a></li><li class="chapter-item expanded "><a href="apis/dRNG.html"><strong aria-hidden="true">6.4.</strong> dRNG</a></li><li class="chapter-item expanded "><a href="apis/communication.html"><strong aria-hidden="true">6.5.</strong> Communication</a></li><li class="chapter-item expanded "><a href="apis/value.html"><strong aria-hidden="true">6.6.</strong> Value layer</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">7.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/docker_private_network.html"><strong aria-hidden="true">7.1.</strong> Docker private network</a></li><li class="chapter-item expanded "><a href="tooling/integration_tests.html"><strong aria-hidden="true">7.2.</strong> Integration tests</a></li></ol></li><li class="chapter-item expanded "><a href="specification.html"><strong aria-hidden="true">8.</strong> Specification of Implementation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/001-mana.html"><strong aria-hidden="true">8.1.</strong> Mana</a></li><li class="chapter-item expanded "><a href="specification/003-markers.html"><strong aria-hidden="true">8.2.</strong> Markers</a></li></ol></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">9.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/glossary.html"><strong aria-hidden="true">9.1.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="concepts/layers.html"><strong aria-hidden="true">9.2.</strong> Layers</a></li></ol></li><li class="chapter-item expanded "><a href="team_resources.html"><strong aria-hidden="true">10.</strong> Team Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="teamresources/release.html"><strong aria-hidden="true">10.1.</strong> How to do a release</a></li><li class="chapter-item expanded "><a href="teamresources/guidelines.html"><strong aria-hidden="true">10.2.</strong> Code Guidelines</a></li><li class="chapter-item expanded "><a href="teamresources/local_development.html"><strong aria-hidden="true">10.3.</strong> Local development</a></li><li class="chapter-item expanded "><a href="../plugins/analysis/dashboard/frontend/index.html"><strong aria-hidden="true">10.4.</strong> Modify the Analysis dashboard</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IOTA GoShimmer</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/iotaledger/goshimmer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the GoShimmer docs!</p>
<p>GoShimmer is a prototype node software exploring the implementation of <a href="https://coordicide.iota.org/">the Coordicide project</a>. This wiki helps the reader to understand the basic concepts and ideas behind the Coordicide and how its modules are implemented in GoShimmer.</p>
<p>Due to the prototypical nature of the project, things written today may not be reflecting how things are tomorrow. We seek to keep the docs as updated as possible, since it is also used as guide for our team. If you find any inconsistencies, feel free to contact us on Discord or better, <a href="https://github.com/iotaledger/goshimmer/issues/new/choose">create an issue on this repository</a>.</p>
<h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h3 id="what-is-goshimmer"><a class="header" href="#what-is-goshimmer">What is GoShimmer?</a></h3>
<p>GoShimmer is a research and engineering project from the IOTA Foundation seeking to evaluate Coordicide concepts by implementing them in a node software.</p>
<h3 id="what-kind-of-confirmation-time-can-i-expect"><a class="header" href="#what-kind-of-confirmation-time-can-i-expect">What kind of confirmation time can I expect?</a></h3>
<p>Since non conflicting transactions aren't even voted up on, they materialize after 2x the average network delay parameter we set. This means that a transaction usually confirms within a time boundary of ~10 seconds.</p>
<h3 id="where-can-i-see-the-state-of-the-pollen-testnet"><a class="header" href="#where-can-i-see-the-state-of-the-pollen-testnet">Where can I see the state of the Pollen testnet?</a></h3>
<p>You can access the global analysis dashboard <a href="http://ressims.iota.cafe:28080/autopeering">here</a> showcasing the network graph and active ongoing votes on conflicts.</p>
<h3 id="how-much-tps-can-goshimmer-sustain"><a class="header" href="#how-much-tps-can-goshimmer-sustain">How much TPS can GoShimmer sustain?</a></h3>
<p>The transactions per second metric is irrelevant for the current development state of GoShimmer. We are evaluating components from Coordicide and aren't currently interested in squeezing out every little ounce of performance. Meaning, we value simplicity over optimization since the primary goal is to evaluate Coordicide components. Even if we would put out a TPS number, it would simply not reflect an actual metric in a finished production ready node software. </p>
<h3 id="how-is-spamming-prevented"><a class="header" href="#how-is-spamming-prevented">How is spamming prevented?</a></h3>
<p>The Coordicide lays out concepts for spam prevention through the means of rate control and such. However, in the current version, GoShimmer relies on PoW to prevent over saturation of the network. Usually doing the PoW for a message will take a couple of seconds on commodity hardware.</p>
<h3 id="what-happens-if-i-issue-a-double-spend"><a class="header" href="#what-happens-if-i-issue-a-double-spend">What happens if I issue a double spend?</a></h3>
<p>If you have funds and are simultaneously issuing transactions spending those, then with high certainty your transactions are going to be rejected by the network. This goes even so far, that your funds will be blocked indefinitely (this might change in the future). If you issue a transaction, await the average network delay and then issue the double spend, then the first issued transaction should usually become confirmed and the 2nd one rejected.</p>
<h3 id="whos-the-target-audience-for-operating-a-goshimmer-node"><a class="header" href="#whos-the-target-audience-for-operating-a-goshimmer-node">Who's the target audience for operating a GoShimmer node?</a></h3>
<p>We are mainly interested in individuals helping us out who have a strong IT background, since we simply lack time to help people with things like setting up their nodes, fixing their NAT configs, teaching them how to use Linux and so on. People interested in trying out the bleeding edge of IOTA development and providing meaningful feedback or problem reporting (in form of issues) are welcome. Again, our primary focus is on testing out Coordicide components rather than giving people of any knowledge-level the easiest way to operate a node.</p>
<h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<h1 id="setting-up-a-goshimmer-node"><a class="header" href="#setting-up-a-goshimmer-node">Setting up a GoShimmer node</a></h1>
<p>This page describes how to setup your own GoShimmer node in the Pollen testnet with Docker.</p>
<blockquote>
<p>DISCLAIMER: <strong>Note that there will be breaking changes frequently (approx. bi-weekly) where the entire network needs to upgrade. If you don't have time to continuously monitor and upgrade your node, then running a GoShimmer node might not be for you.</strong>  We want to emphasize that running a GoShimmer node requires proper knowledge in Linux and IT related topics such as networking and so on. It is not meant as a node to be run by people with little experience in the mentioned fields. <strong>Do not plan to run any production level services on your node/network.</strong></p>
</blockquote>
<table><thead><tr><th align="left">Contents</th></tr></thead><tbody>
<tr><td align="left"><a href="tutorials/setup.html#why-you-should-run-a-node">Why you should run a node</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#running-the-goshimmer-node">Running the GoShimmer node</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></td></tr>
<tr><td align="left"><a href="tutorials/setup.html#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></td></tr>
</tbody></table>
<h2 id="why-you-should-run-a-node"><a class="header" href="#why-you-should-run-a-node">Why you should run a node</a></h2>
<p>Running a node in the Pollen testnet helps us in the following ways:</p>
<ul>
<li>It increases the amount of nodes in the network and thus lets it form a more realistic network.</li>
<li>Your node will be configured to send debug log messages to a centralized logger from which we can assess and debug research questions and occurring problems.</li>
<li>Your node is configured to send metric data to a centralized analysis server where we store information such as resource consumption, traffic, FPC vote context processing and so on. This data helps us further fostering the development of GoShimmer and assessing network behavior.</li>
<li>If you expose your HTTP API port, you provide an entrypoint for other people to interact with the network.</li>
</ul>
<blockquote>
<p>Note that any metric data is anonymous.</p>
</blockquote>
<h2 id="installing-goshimmer-with-docker"><a class="header" href="#installing-goshimmer-with-docker">Installing GoShimmer with Docker</a></h2>
<h4 id="hardware-requirements"><a class="header" href="#hardware-requirements">Hardware Requirements</a></h4>
<blockquote>
<p>Note that we do not provide a Docker image or binaries for ARM based systems such as Raspberry Pis.</p>
</blockquote>
<p>We recommend running GoShimmer on a x86 VPS with following minimum hardware specs:</p>
<ul>
<li>2 cores / 4 threads</li>
<li>4 GB of memory</li>
<li>40 GB of disk space</li>
</ul>
<p>A cheap <a href="https://www.hetzner.de/cloud">CX21 Hetzner instance</a> is thereby sufficient.</p>
<p>If you plan on running your GoShimmer node from home, please only do so if you know how to properly configure NAT on your router, as otherwise your node will not correctly participate in the network.</p>
<hr />
<blockquote>
<p>In the following sections we are going to use a CX21 Hetzner instance with Ubuntu 20.04 while being logged in as root</p>
</blockquote>
<p>Lets first upgrade the packages on our system:</p>
<pre><code>$ apt update &amp;&amp; apt dist-upgrade -y
</code></pre>
<h4 id="install-docker"><a class="header" href="#install-docker">Install Docker</a></h4>
<p>Install needed dependencies:</p>
<pre><code>$ apt-get install \
     apt-transport-https \
     ca-certificates \
     curl \
     gnupg-agent \
     software-properties-common
</code></pre>
<p>Add Docker’s official GPG key:</p>
<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</code></pre>
<p>Verify that the GPG key matches:</p>
<pre><code>$ apt-key fingerprint 0EBFCD88
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;
sub   rsa4096 2017-02-22 [S]

</code></pre>
<p>Add the actual repository:</p>
<pre><code>$ add-apt-repository \
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable&quot;
</code></pre>
<p>Update the package index:</p>
<pre><code>$ apt-get update
</code></pre>
<p>And finally, install docker:</p>
<pre><code>$ apt-get install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>On windows-subsystem for Linux (WSL2) it may be necessary to start docker seperately:</p>
<pre><code>$ /etc/init.d/docker start
</code></pre>
<p>Note, this may not work on WSL1.</p>
<p>Check whether docker is running by executing <code>docker ps</code>:</p>
<pre><code>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</code></pre>
<h3 id="install-docker-compose"><a class="header" href="#install-docker-compose">Install Docker Compose</a></h3>
<p>Docker compose gives us the ability to define our services with <code>docker-compose.yml</code> files instead of having to define all container parameters directly on the CLI.</p>
<p>Download docker compose:</p>
<pre><code>$ curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
</code></pre>
<p>Make it executable:</p>
<pre><code>$ chmod +x /usr/local/bin/docker-compose
</code></pre>
<p>Check that docker compose works:</p>
<pre><code>$ docker-compose --version
docker-compose version 1.26.0, build d4451659
</code></pre>
<h3 id="define-the-docker-composeyml"><a class="header" href="#define-the-docker-composeyml">Define the docker-compose.yml</a></h3>
<p>First, lets create a user defined bridged network. Unlike the already existing <code>bridge</code> network, the user defined one will have container name DNS resolution for containers within that network. This is useful if later we want to setup additional containers which need to speak with the GoShimmer container.</p>
<pre><code>$ docker network create --driver=bridge shimmer
c726034d295c3df66803b92c71ca517a0cf0e3c65c1c6d84ee5fa34ae76cbcd4
</code></pre>
<p>Lets create a folder holding our <code>docker-compose.yml</code>:</p>
<pre><code>$ mkdir /opt/goshimmer
</code></pre>
<p>Lets create a folder holding our database:</p>
<pre><code>$ cd /opt/goshimmer
$ mkdir db
$ chmod 0777 db
</code></pre>
<p>Finally, lets create our <code>docker-compose.yml</code>:</p>
<pre><code>$ nano docker-compose.yml
</code></pre>
<p>and add following content:</p>
<pre><code class="language-yaml">version: '3.3'

networks:
  outside:
    external:
      name: shimmer

services:
  goshimmer:
    image: iotaledger/goshimmer:latest
    container_name: goshimmer
    hostname: goshimmer
    stop_grace_period: 2m
    volumes:
      - &quot;./db:/tmp/mainnetdb:rw&quot;   
      - &quot;/etc/localtime:/etc/localtime:ro&quot;
    ports:
      # Autopeering 
      - &quot;0.0.0.0:14626:14626/udp&quot;
      # Gossip
      - &quot;0.0.0.0:14666:14666/tcp&quot;
      # FPC
      - &quot;0.0.0.0:10895:10895/tcp&quot;
      # HTTP API
      - &quot;0.0.0.0:8080:8080/tcp&quot;
      # Dashboard
      - &quot;0.0.0.0:8081:8081/tcp&quot;
      # pprof profiling
      - &quot;0.0.0.0:6061:6061/tcp&quot;
    environment:
      - ANALYSIS_CLIENT_SERVERADDRESS=ressims.iota.cafe:21888
      - AUTOPEERING_PORT=14626
      - DASHBOARD_BINDADDRESS=0.0.0.0:8081
      - GOSSIP_PORT=14666
      - WEBAPI_BINDADDRESS=0.0.0.0:8080
      - PROFILING_BINDADDRESS=0.0.0.0:6061
      - NETWORKDELAY_ORIGINPUBLICKEY=9DB3j9cWYSuEEtkvanrzqkzCQMdH1FGv3TawJdVbDxkd
      - FPC_BINDADDRESS=0.0.0.0:10895
      - PROMETHEUS_BINDADDRESS=0.0.0.0:9311
    command: &gt;
      --skip-config=true
      --autopeering.entryNodes=2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626,5EDH4uY78EA6wrBkHHAVBWBMDt7EcksRq6pjzipoW15B@entryshimmer.tanglebay.com:14646
      --node.disablePlugins=
      --node.enablePlugins=remotelog,networkdelay,spammer,prometheus
      --logger.level=info
      --logger.disableEvents=false
      --logger.remotelog.serverAddress=ressims.iota.cafe:5213
      --drng.pollen.instanceId=1
      --drng.pollen.threshold=3
      --drng.pollen.committeeMembers=AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG,FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z,GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P,4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7,64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga
      --drng.xteam.instanceId=1339
      --drng.xteam.threshold=4
      --drng.xteam.committeeMembers=GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo,68vNzBFE9HpmWLb2x4599AUUQNuimuhwn3XahTZZYUHt,Dc9n3JxYecaX3gpxVnWb4jS3KVz1K1SgSK1KpV1dzqT1,75g6r4tqGZhrgpDYZyZxVje1Qo54ezFYkCw94ELTLhPs,CN1XLXLHT9hv7fy3qNhpgNMD6uoHFkHtaNNKyNVCKybf,7SmttyqrKMkLo5NPYaiFoHs8LE6s7oCoWCQaZhui8m16,CypSmrHpTe3WQmCw54KP91F5gTmrQEL7EmTX38YStFXx
    networks:
      - outside
</code></pre>
<blockquote>
<p>If performance is a concern, you can also run your containers with <code>network_mode: &quot;host&quot;</code>, however, you must then adjust the hostnames in the configs for the corresponding containers and perhaps also create some iptable rules to block traffic from outside accessing your services directly.</p>
</blockquote>
<p>Note how we are setting up NATs for different ports:</p>
<table><thead><tr><th>Port</th><th>Functionality</th><th>Protocol</th></tr></thead><tbody>
<tr><td>14626</td><td>Autopeering</td><td>UDP</td></tr>
<tr><td>14666</td><td>Gossip</td><td>TCP</td></tr>
<tr><td>10895</td><td>FPC</td><td>TCP/HTTP</td></tr>
<tr><td>8080</td><td>HTTP API</td><td>TCP/HTTP</td></tr>
<tr><td>8081</td><td>Dashboard</td><td>TCP/HTTP</td></tr>
<tr><td>6061</td><td>pprof HTTP API</td><td>TCP/HTTP</td></tr>
</tbody></table>
<p>It is important that the ports are correctly mapped so that the node for example actively participates in FPC votes or can gain inbound neighbors.</p>
<blockquote>
<p>If the UDP NAT mapping is not configured correctly, GoShimmer will terminate with an error message stating to check the NAT configuration</p>
</blockquote>
<h2 id="running-the-goshimmer-node"><a class="header" href="#running-the-goshimmer-node">Running the GoShimmer node</a></h2>
<p>Within the <code>/opt/goshimmer</code> folder where the <code>docker-compose.yml</code> resides, simply execute:</p>
<pre><code>$ docker-compose up -d
Pulling goshimmer (iotaledger/goshimmer:0.2.0)...
...
</code></pre>
<p>to start the GoShimmer node.</p>
<p>You should see your container running now:</p>
<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                                                                    NAMES
687f52b78cb5        iotaledger/goshimmer:0.2.0       &quot;/run/goshimmer --sk…&quot;   19 seconds ago      Up 17 seconds       0.0.0.0:6061-&gt;6061/tcp, 0.0.0.0:8080-8081-&gt;8080-8081/tcp, 0.0.0.0:10895-&gt;10895/tcp, 0.0.0.0:14666-&gt;14666/tcp, 0.0.0.0:14626-&gt;14626/udp   goshimmer
</code></pre>
<p>You can follow the log output of the node via:</p>
<pre><code>$ docker logs -f --since=1m goshimmer
</code></pre>
<h3 id="syncing"><a class="header" href="#syncing">Syncing</a></h3>
<p>When the node starts for the first time, it must synchronize its state with the rest of the network. GoShimmer currently uses a sync beacon mechanism to help nodes determine their synced status and help syncing messages.</p>
<p>Follow these links to learn more about <a href="tutorials/./syncbeacon.html">how sync beacons work, why you should run sync beacons</a> on your node and how to <a href="tutorials/./follow_syncbeacon.html">configure your node to listen to certain sync beacons</a>.</p>
<h4 id="dashboard"><a class="header" href="#dashboard">Dashboard</a></h4>
<p>The dashboard of your GoShimmer node should be accessible via <code>http://&lt;your-ip&gt;:8081</code>. If your node is still synchronizing, you might see a higher inflow of MPS.</p>
<p><img src="https://i.imgur.com/8xAvi7X.png" alt="" /></p>
<p>After a while, your node's dashboard should also display up to 8 neighbors:
<img src="https://i.imgur.com/gAyAXK9.png" alt="" /></p>
<h4 id="http-api"><a class="header" href="#http-api">HTTP API</a></h4>
<p>GoShimmer also exposes an HTTP API. To check whether that works correctly, you can access it via <code>http://&lt;your-ip&gt;:8080/info</code> which should return a JSON response in the form of:</p>
<pre><code>{
  &quot;version&quot;: &quot;v0.2.0&quot;,
  &quot;synced&quot;: true,
  &quot;identityID&quot;: &quot;69RxiehGQ2c&quot;,
  &quot;publicKey&quot;: &quot;52Gzw9bo7k2dARFi4yxtt3B8xMht5UeFQX7pWdLFnxV5&quot;,
  &quot;enabledPlugins&quot;: [
    &quot;Analysis-Client&quot;,
    &quot;Autopeering&quot;,
    &quot;CLI&quot;,
    &quot;Config&quot;,
    &quot;DRNG&quot;,
    &quot;Dashboard&quot;,
    &quot;Database&quot;,
    &quot;Gossip&quot;,
    ...
    &quot;WebAPI info Endpoint&quot;,
    &quot;WebAPI message Endpoint&quot;
  ],
  &quot;disabledPlugins&quot;: [
    &quot;Analysis-Dashboard&quot;,
    &quot;Analysis-Server&quot;,
    &quot;Banner&quot;,
    &quot;Bootstrap&quot;,
    &quot;Faucet&quot;,
    &quot;WebAPI Auth&quot;
  ]
}
</code></pre>
<h2 id="managing-the-goshimmer-node-lifecycle"><a class="header" href="#managing-the-goshimmer-node-lifecycle">Managing the GoShimmer node lifecycle</a></h2>
<h5 id="stopping-the-node"><a class="header" href="#stopping-the-node">Stopping the node</a></h5>
<pre><code>$ docker-compose stop
</code></pre>
<h5 id="resetting-the-node"><a class="header" href="#resetting-the-node">Resetting the node</a></h5>
<pre><code>$ docker-compose down
</code></pre>
<h5 id="upgrading-the-node"><a class="header" href="#upgrading-the-node">Upgrading the node</a></h5>
<p><strong>Ensure that the image version in the <code>docker-compose.yml</code> is <code>latest</code></strong> then execute following commands:</p>
<pre><code>$ docker-compose down
$ rm db/*
$ docker-compose pull
$ docker-compose up -d
</code></pre>
<h5 id="following-log-output"><a class="header" href="#following-log-output">Following log output</a></h5>
<pre><code>$ docker logs -f --since=1m goshimmer
</code></pre>
<h5 id="create-a-logtxt"><a class="header" href="#create-a-logtxt">Create a log.txt</a></h5>
<pre><code>$ docker logs goshimmer &gt; log.txt
</code></pre>
<h5 id="update-grafana-dashboard"><a class="header" href="#update-grafana-dashboard">Update Grafana Dashboard</a></h5>
<p>If you set up the Grafana dashboard for your node according to the next section &quot;Setting up the Grafana dashboard&quot;, the following method will help you to update when a new version is released.</p>
<p>You have to manually copy the new <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">dashboard file</a> into <code>/opt/goshimmer/grafana/dashboards</code> directory.
Supposing you are at <code>/opt/goshimmer/</code>:</p>
<pre><code>$ wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
$ cp local_dashboard.json grafana/dashboards
</code></pre>
<p>Restart the grafana container:</p>
<pre><code>$ docker restart grafana
</code></pre>
<h2 id="setting-up-the-grafana-dashboard"><a class="header" href="#setting-up-the-grafana-dashboard">Setting up the Grafana dashboard</a></h2>
<h4 id="add-prometheus-and-grafana-containers-to-docker-composeyml"><a class="header" href="#add-prometheus-and-grafana-containers-to-docker-composeyml">Add Prometheus and Grafana Containers to <code>docker-compose.yml</code></a></h4>
<p>Append the following to the previously described <code>docker-compose.yml</code> file (<strong>make sure to also copy the space in front of &quot;prometheus&quot;/the entire whitespace</strong>):</p>
<pre><code class="language-yaml">  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - &quot;9090:9090/tcp&quot;
    command:
      - --config.file=/etc/prometheus/prometheus.yml
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./prometheus/data:/prometheus:rw
    depends_on:
      - goshimmer
    networks:
      - outside

  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    environment:
      # path to provisioning definitions can only be defined as
      # environment variables for grafana within docker
      - GF_PATHS_PROVISIONING=/var/lib/grafana/provisioning
    ports:
      - &quot;3000:3000/tcp&quot;
    user: &quot;472&quot;
    volumes:
      - ./grafana:/var/lib/grafana:rw
    networks:
      - outside
</code></pre>
<h4 id="create-prometheus-config"><a class="header" href="#create-prometheus-config">Create Prometheus config</a></h4>
<ol>
<li>Create a <code>prometheus/data</code> directory in <code>/opt/goshimmer</code>:</li>
</ol>
<pre><code>$ cd /opt/goshimmer
$ mkdir -p prometheus/data
</code></pre>
<ol start="2">
<li>Create a <code>prometheus.yml</code> in <code>prometheus</code> directory:</li>
</ol>
<pre><code>$ nano prometheus/prometheus.yml
</code></pre>
<p>The content of the file should be:</p>
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        - goshimmer:9311
</code></pre>
<ol start="3">
<li>Add permissions to <code>prometheus</code> config directory:</li>
</ol>
<pre><code>$ chmod -R 777 prometheus
</code></pre>
<h4 id="create-grafana-configs"><a class="header" href="#create-grafana-configs">Create Grafana configs</a></h4>
<ol>
<li>Create necessary config dirs in <code>/opt/goshimmer/</code>.</li>
</ol>
<pre><code>$ mkdir -p grafana/provisioning/datasources grafana/provisioning/dashboards grafana/provisioning/notifiers
$ mkdir -p grafana/dashboards
</code></pre>
<ol start="2">
<li>Create a datasource configuration file in <code>grafana/provisioning/datasources</code>:</li>
</ol>
<pre><code>$ nano grafana/provisioning/datasources/datasources.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    # &lt;string, required&gt; access mode. proxy or direct (Server or Browser in the UI). Required
    access: proxy
    orgId: 1
    url: http://prometheus:9090
    jsonData:
      graphiteVersion: '1.1'
      timeInterval: '1s'
    # &lt;string&gt; json object of data that will be encrypted.
    secureJsonData:
      # &lt;string&gt; database password, if used
      password:
      # &lt;string&gt; basic auth password
      basicAuthPassword:
    version: 1
    # &lt;bool&gt; allow users to edit datasources from the UI.
    editable: true
</code></pre>
<ol start="3">
<li>Create a dashboard configuration file in <code>grafana/provisioning/dashboards</code>:</li>
</ol>
<pre><code>$ nano grafana/provisioning/dashboards/dashboards.yaml
</code></pre>
<p>With the following content:</p>
<pre><code class="language-yaml">apiVersion: 1

providers:
  - name: 'Goshimmer Local Metrics'
    orgId: 1
    folder: ''
    type: file
    disableDeletion: false
    editable: true
    updateIntervalSeconds: 10
    allowUiUpdates: true
    options:
      path: /var/lib/grafana/dashboards
</code></pre>
<ol start="4">
<li>Add predefined Goshimmer Local Metrics Dashboard.</li>
</ol>
<p>Head over to the GoShimmer repository and download <a href="https://github.com/iotaledger/goshimmer/blob/master/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a>.</p>
<pre><code>$ wget https://raw.githubusercontent.com/iotaledger/goshimmer/master/tools/monitoring/grafana/dashboards/local_dashboard.json
$ cp local_dashboard.json grafana/dashboards
</code></pre>
<ol start="5">
<li>Add permissions to Grafana config folder</li>
</ol>
<pre><code>$ chmod -R 777 grafana
</code></pre>
<h4 id="run-goshimmer-with-prometheus-and-grafana"><a class="header" href="#run-goshimmer-with-prometheus-and-grafana">Run GoShimmer with Prometheus and Grafana:</a></h4>
<pre><code>$ docker-compose up -d
</code></pre>
<p>The Grafana dashboard should be accessible at <code>http://&lt;your-ip&gt;:3000</code>.</p>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code>: admin</li>
<li><code>password</code>: admin</li>
</ul>
<h1 id="how-to-obtain-tokens-from-the-faucet"><a class="header" href="#how-to-obtain-tokens-from-the-faucet">How to obtain tokens from the faucet</a></h1>
<h2 id="the-faucet-dapp"><a class="header" href="#the-faucet-dapp">The faucet dApp</a></h2>
<p>The faucet is a dApp built on top of the <a href="tutorials/../concepts/layers.html">value and communication layer</a>. It sends IOTA tokens to addresses by listening to faucet request messages. A faucet message is a Message containing an address encoded in Base58, and it is retrievable via <a href="tutorials/../apis/communication.html"><code>FindMessageByID()</code></a>.
After sending a faucet request message, you can check your balances via <a href="tutorials/../apis/value.html"><code>GetUnspentOutputs()</code></a>.</p>
<h2 id="obtain-tokens-from-the-faucet"><a class="header" href="#obtain-tokens-from-the-faucet">Obtain tokens from the faucet</a></h2>
<p>There are 3 ways to send a faucet request message to obtain IOTA tokens:</p>
<ol>
<li>Via the Go client library</li>
<li>Via the HTTP API directly</li>
<li>Requesting tokens via the GoShimmer web dashboard</li>
<li>Via the wallet</li>
</ol>
<h3 id="via-the-go-client-library"><a class="header" href="#via-the-go-client-library">Via the Go client library</a></h3>
<p>Follow the instructions in <a href="tutorials/../apis/api.html">Use the API</a> to set up the API instance. </p>
<p>Example:</p>
<pre><code>// provide your Base58 encoded destination address
messageID, err := goshimAPI.SendFaucetRequest(&quot;JaMauTaTSVBNc13edCCvBK9fZxZ1KKW5fXegT1B7N9jY&quot;)

---- or

// get the given address from your wallet instance and 
// use String() to get its Base58 representation
addr := wallet.Seed().Address(0)
messageID, err := goshimAPI.SendFaucetRequest(addr.String())
</code></pre>
<h3 id="via-the-http-api-directly"><a class="header" href="#via-the-http-api-directly">Via the HTTP API directly</a></h3>
<p>The URI for POSTing faucet request messages is <code>http://&lt;host&gt;:&lt;web-api-port&gt;/faucet</code></p>
<table><thead><tr><th>Parameter</th><th>Required</th><th>Description</th><th>Type</th></tr></thead><tbody>
<tr><td><code>address</code></td><td>Yes</td><td>Destination address to which to send tokens to encoded in Base58</td><td>string</td></tr>
</tbody></table>
<p>cURL example:</p>
<pre><code>curl http://localhost:8080 \
-X POST \
-H 'Content-Type: application/json' \
-d '{
  &quot;address&quot;: &quot;JaMauTaTSVBNc13edCCvBK9fZxZ1KKW5fXegT1B7N9jY&quot;
}'
</code></pre>
<h3 id="requesting-tokens-via-the-goshimmer-web-dashboard"><a class="header" href="#requesting-tokens-via-the-goshimmer-web-dashboard">Requesting tokens via the GoShimmer web dashboard</a></h3>
<p>You can send the faucet request message via the faucet tab on the dashboard by filling in a Base58 encoded address to receive tokens.</p>
<p>You can then use the link provided below to check the funds on your supplied address.</p>
<img src="https://user-images.githubusercontent.com/11289354/85510396-d9127000-b629-11ea-8d5c-d5bb10d7c34a.png" width="650">
<h3 id="via-the-wallet"><a class="header" href="#via-the-wallet">Via the wallet</a></h3>
<p>Currently, there are two GUI wallets to use, one from the community member <a href="https://github.com/Dr-Electron/ElectricShimmer">Dr-Electron ElectricShimmer</a> and another from the foundation <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a>. You can request funds from the faucet with these two implementations.</p>
<p>As for pollen-wallet, follow the instructions in <a href="https://github.com/iotaledger/pollen-wallet/tree/master">pollen-wallet</a> to build and execute the wallet.</p>
<p>You can request funds by pressing the <code>Request Funds</code> in the wallet.</p>
<p><strong>Note</strong>: You need to create a wallet first before requesting funds.</p>
<img src="https://user-images.githubusercontent.com/11289354/88524828-70edea00-d02c-11ea-9a01-d7e1a8b7bdfd.png" height="450">
<p>This may take a while to receive funds:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525200-e0fc7000-d02c-11ea-9f7f-a545cf14b318.png" width="450">
<p>When the faucet request is successful, you can check the received balances:</p>
<img src="https://user-images.githubusercontent.com/11289354/88525478-38024500-d02d-11ea-92c7-25c80eb6a947.png" width="450">
<h1 id="the-wallet-library"><a class="header" href="#the-wallet-library">The wallet library</a></h1>
<p>This page describes how to use the wallet library.</p>
<p>GoShimmer ships with a very basic wallet library so that developers and testers can use it to move tokens around.</p>
<p>To demonstrate its functionalities we have developed a simple command line interface (cli-wallet). 
You can have a look at its source code to have an idea about how the wallet library can be used. </p>
<p>The cli-wallet supports the following commands:</p>
<img src="https://user-images.githubusercontent.com/11289354/88368467-b8703e00-cdc0-11ea-83b2-757c8b9e25c8.png" height="400">
<h1 id="how-to-create-a-simple-dapp"><a class="header" href="#how-to-create-a-simple-dapp">How to create a simple dApp</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<blockquote>
<p><strong>DISCLAIMER:</strong> GoShimmer is a rapidly evolving prototype software. As such, the described steps here will likely change in the future. Specifically, we are envisioning to ease the process of dApp creation and installation for node owners. Furthermore, the current approach is in no way hardened and should be seen as purely experimental. Do not write any software for actual production use.</p>
</blockquote>
<h2 id="network-delay-dapp"><a class="header" href="#network-delay-dapp">Network Delay dApp</a></h2>
<p>In this guide we are going to explain how to write a very simple dApp based on an actual dApp we are using in GoShimmer to help us measure the network delay, i.e., how long it takes for every active node in the network to receive a message. Gathering this data will enable us to set realistic parameters for FCoB.</p>
<p>The complete source code of the application can be found <a href="https://github.com/iotaledger/goshimmer/tree/develop/dapps/networkdelay">in the repository</a>. </p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>Our network delay dApp should help us to identify the time it takes for every active node to receive and process a message. That can be done in a few simple steps:</p>
<ol>
<li>A (known) node sends a special message containing a network delay object.</li>
<li>Upon receipt, every other node in the network answers to the special message by posting its current time to our remote logger.</li>
<li>For simplicity we gather the information in an <a href="https://www.elastic.co/what-is/elk-stack">ELK stack</a>. This helps us to easily interpret and analyze the data.</li>
</ol>
<p>Within GoShimmer we need 3 components to realize this undertaking. First, we need to <strong>define and register a network delay object type</strong>. Second, we need a way to <strong>initiate a message</strong> with a network delay object via the web API. And lastly, we need to <strong>listen</strong> for network delay objects and take appropriate action.</p>
<p>If a node does not have our dApp installed and activated, the message will be simply treated as a raw data message without any particular meaning. In general that means that in order for a dApp to be useful, node owners need to explicitly install it. In our case we simply ship it with GoShimmer.</p>
<h3 id="define--register-the-network-delay-object"><a class="header" href="#define--register-the-network-delay-object">Define &amp; Register The Network Delay Object</a></h3>
<p>First, we need to decide what data our network delay object should contain and define the byte layout accordingly.
In our case we need an <code>ID</code> to identify a network delay message and the <code>sent time</code> of the initiator. 
Therefore, we can define the byte layout as follows:</p>
<pre><code>type&lt;uint32-4bytes&gt; // every object has to have this
length&lt;uint32-4bytes&gt; // every object has to have this
id&lt;32bytes&gt;
sentTime&lt;int64-8bytes&gt;
</code></pre>
<p>Next, we need to fulfill the <code>Payload</code> interface and provide the functionality to read/write an object from/to bytes. The <a href="https://github.com/iotaledger/hive.go/tree/master/marshalutil"><code>hive.go/marshalutil</code></a> package simplifies this step tremendously.</p>
<pre><code class="language-Go">type Payload interface {
	// Type returns the type of the payload.
	Type() Type
	// Bytes returns the payload bytes.
	Bytes() []byte
	// Unmarshal unmarshals the payload from the given bytes.
	Unmarshal(bytes []byte) error
	// String returns a human-friendly representation of the payload.
	String() string
}
</code></pre>
<p>Finally, we need to register our network delay object type so that it can be properly unmarshalled. </p>
<pre><code class="language-Go">func init() {
	payload.RegisterType(Type, func(data []byte) (payload payload.Payload, err error) {
		payload = &amp;Object{}
		err = payload.Unmarshal(data)

		return
	})
}
</code></pre>
<h3 id="create-the-web-api-endpoints"><a class="header" href="#create-the-web-api-endpoints">Create The Web API Endpoints</a></h3>
<p>In order to issue a message with our newly created network delay object, we need to create a web API endpoint. Here we simply create a random <code>ID</code> and the <code>sentTime</code> and then issue a message with <code>issuer.IssuePayload()</code>. This plugin takes care of all the specifics and employs the <code>MessageFactory</code> to, i.a., select tips and sign the message.</p>
<pre><code class="language-Go">webapi.Server.POST(&quot;networkdelay&quot;, broadcastNetworkDelayObject)

func broadcastNetworkDelayObject(c echo.Context) error {
	// generate random id
	rand.Seed(time.Now().UnixNano())
	var id [32]byte
	if _, err := rand.Read(id[:]); err != nil {
		return c.JSON(http.StatusInternalServerError, Response{Error: err.Error()})
	}

	msg, err := issuer.IssuePayload(NewObject(id, time.Now().UnixNano()))
	if err != nil {
		return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
	}
	return c.JSON(http.StatusOK, Response{ID: msg.Id().String()})
}
</code></pre>
<h3 id="listen-for-network-delay-objects"><a class="header" href="#listen-for-network-delay-objects">Listen for network delay objects</a></h3>
<p>Every dApp listens for messages from the <em>communication layer</em> and when its data type is detected, takes appropriate action. For us that means listening for network delay objects and sending messages to our remote logger if we encounter any. Of course in this context, we only want to react to network delay objects which were issued by our analysis/entry node server. Therefore, matching the message signer's public key with a configured public key lets us only react to the appropriate network delay objects.</p>
<pre><code class="language-Go">// subscribe to message-layer
messagelayer.Tangle.Events.MessageSolid.Attach(events.NewClosure(onReceiveMessageFromMessageLayer))

func onReceiveMessageFromMessageLayer(cachedMessage *message.CachedMessage, cachedMessageMetadata *messageTangle.CachedMessageMetadata) {
	defer cachedMessage.Release()
	defer cachedMessageMetadata.Release()

	solidMessage := cachedMessage.Unwrap()
	if solidMessage == nil {
		log.Debug(&quot;failed to unpack solid message from message layer&quot;)

		return
	}

	messagePayload := solidMessage.Payload()
	if messagePayload.Type() != Type {
		return
	}

	// check for node identity -&gt; only answer if it's send from a configured node
	issuerPubKey := solidMessage.IssuerPublicKey()
	if issuerPubKey != originPublicKey || issuerPubKey == myPublicKey {
		return
	}

	// make sure we really got a message with our type. 
	// since we are in a distributed setting anyone could send a message with our type id and put other data in it.
	networkDelayObject, ok := messagePayload.(*Object)
	if !ok {
		log.Info(&quot;could not cast payload to network delay object&quot;)

		return
	}

	now := time.Now().UnixNano()

	sendToRemoteLog(networkDelayObject, now)
}
</code></pre>
<h1 id="how-to-run-a-sync-beacon"><a class="header" href="#how-to-run-a-sync-beacon">How to run a sync beacon</a></h1>
<h2 id="what-is-a-sync-beacon"><a class="header" href="#what-is-a-sync-beacon">What is a sync beacon?</a></h2>
<p>A sync beacon is a special type of payload in the message tangle. It contains the unix timestamp of issuance of the beacon. Node owners may configure their nodes to distribute such sync beacons periodically to the network. Followers can listen to sync beacons issued by a particular set of nodes, and derive their <code>synced</code> status based on if they are able to solidify the messages containing those sync beacons.</p>
<h2 id="why-should-i-run-a-sync-beacon"><a class="header" href="#why-should-i-run-a-sync-beacon">Why should I run a sync beacon?</a></h2>
<p>Simply put: the more sync beacons there are in the network, the easier it is for followers to accurately determine their synced status.</p>
<p>Followers are free to choose which nodes to follow, and to what percentage of the nodes they need to be synced to, in order to consider themselves synced. The correct determination of the <code>synced</code> state is not only important for knowing the current status of your node, but also to build a healthy Tangle. You want to attach messages to recent tips, tips that are also known to others in the network, which you only know by being in sync with them.</p>
<h2 id="how-to-enable-the-sync-beacon-plugin"><a class="header" href="#how-to-enable-the-sync-beacon-plugin">How to enable the sync beacon plugin?</a></h2>
<p>All you need to do is enable the <code>syncbeacon</code> plugin in your node config. To do it via <code>config.json</code>, add it to the list of enabled plugins:</p>
<pre><code>  &quot;node&quot;: {
    &quot;disablePlugins&quot;: [],
    &quot;enablePlugins&quot;: [&quot;syncbeacon&quot;]
  },
</code></pre>
<p>You may also configure how often your node should send a sync beacon with <code>broadcastInterval</code> (seconds):</p>
<pre><code>...
  },
  &quot;syncbeacon&quot;: {
    &quot;broadcastInterval&quot;: 30
  },
...
</code></pre>
<h1 id="how-to-configure-followed-sync-beacon-nodes"><a class="header" href="#how-to-configure-followed-sync-beacon-nodes">How to configure followed sync beacon nodes</a></h1>
<h2 id="why-do-you-need-to-follow-sync-beacons"><a class="header" href="#why-do-you-need-to-follow-sync-beacons">Why do you need to follow sync beacons?</a></h2>
<p><a href="tutorials/./syncbeacon.html">Sync beacons</a> help your node to determine its synced status. To conclude that your node has the same view on the Tangle in a fully decentralized network, you have to rely on information coming from your peers. Sync beacons are part of the mechanism that lets you do exactly this.</p>
<p>You listen to sync beacons in the message Tangle from your choice of nodes, and try to solidify them. If successfully done within a predefined time window, you conclude that your node is <code>synced</code> compared to the node that issued the sync beacon. Since you can follow an arbitrary number of sync beacon nodes, your <code>own synced</code> status is determined as a quorum of your <code>synced</code> status compared to others. The quorum size (in percentage) is configurable via config file or cli flags, but has to be within the [0.5, 1.0] interval. <code>0.5</code> means that you have to be in sync at least to half of the nodes you are following, <code>1.0</code> means that you have to be synced to all of them.</p>
<h2 id="follow-a-set-of-nodes"><a class="header" href="#follow-a-set-of-nodes">Follow a set of nodes</a></h2>
<p>To configure which nodes to follow, you have to specify their public key in your node's <code>config.json</code>:</p>
<pre><code>  &quot;syncbeaconfollower&quot;: {
    &quot;followNodes&quot;: [
      &quot;98u5J7Xz4CS6efttPGYLgetZCAmpXpNiUbhAP6mmUHfW&quot;,
      &quot;EpPTtBhkr1fAQJGTVqkE6XoSDeS5k5awEo7s4UeLSR2Y&quot;
    ]
  },
</code></pre>
<p>If you don't specify any nodes in your config, your node will only follow two predefined sync beacon nodes.</p>
<h2 id="configure-sync-quorum-size"><a class="header" href="#configure-sync-quorum-size">Configure sync quorum size</a></h2>
<p>To configure the quorum size, use the <code>syncPercentage</code> config parameter:</p>
<pre><code>  &quot;syncbeaconfollower&quot;: {
    &quot;followNodes&quot;: [
      &quot;98u5J7Xz4CS6efttPGYLgetZCAmpXpNiUbhAP6mmUHfW&quot;,
      &quot;EpPTtBhkr1fAQJGTVqkE6XoSDeS5k5awEo7s4UeLSR2Y&quot;
    ],
    &quot;syncPercentage&quot;: 0.8
  },
</code></pre>
<p>If you don't specify <code>syncPercentage</code> in your config, or it is outside the [0.5, 1.0] interval, the quorum size will default to <code>0.5</code> (50%).</p>
<h2 id="observe-synced-status-on-your-local-dashboard"><a class="header" href="#observe-synced-status-on-your-local-dashboard">Observe synced status on your local dashboard</a></h2>
<p>Your node dashboard will display the <code>synced</code> information related to the nodes that you follow. You can see the latest beacons which were used to derive the synced status, and the time of their issuance.</p>
<p><img src="https://i.imgur.com/4QXwhyJ.png" alt="Sync status on local dashboard" /></p>
<h1 id="create-a-static-identity"><a class="header" href="#create-a-static-identity">Create a static identity</a></h1>
<p>To create a static GoShimmer identity, you will need to generate a random 32byte autopeering seed. You can use <code>openssl</code> or the <code>rand-seed</code> tool we provide under the GoShimmer folder <code>tools/rand-seed</code>.
For example, by running:</p>
<ul>
<li><code>openssl rand -base64 32</code>: generates a random 32 byte sequence encoded in base64. The output should look like: <code>gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=</code></li>
<li><code>go run main.go</code> under the GoShimmer folder <code>tools/rand-seed</code>: generates a random 32 byte sequence encoded in both base64 and base58. The output is written into the file <code>random-seed.txt</code> and should look like:</li>
</ul>
<pre><code>base64:nQW9MhNSLpIqBUiZe90XI320g680zxFoB1UIK09Acus=
base58:BZx5tDLymckUV5wiswXJtajgQrBEzTBBRR4uGfr1YNGS
</code></pre>
<p>You can now copy one of that strings (together with the encoding type prefix) and paste it into the GoShimmer <code>config.json</code> under the <code>autopeering</code> section:</p>
<pre><code>&quot;autopeering&quot;: {
    &quot;entryNodes&quot;: [
      &quot;2PV5487xMw5rasGBXXWeqSi4hLz7r19YBt8Y1TGAsQbj@ressims.iota.cafe:15626&quot;
    ],
    &quot;port&quot;: 14626,
    &quot;seed&quot;:&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
  },
</code></pre>
<p>Or if you are using docker and prefer to set this with a command, you can define the same by changing the GoShimmer docker-compose.yml:</p>
<pre><code class="language-yml">goshimmer:
    network_mode: host
    image: iotaledger/goshimmer
    build:
      context: ./
      dockerfile: Dockerfile
    container_name: iota_goshimmer
    command: &gt;
      --node.enablePlugins=prometheus
      --autopeering.seed=&quot;base64:gP0uRLhwBG2yJJmnLySX4S4R5G250Z3dbN9yBR6VSyY=&quot;
    # Mount volumes:
    # make sure to give read/write access to the folder ./mainnetdb (e.g., chmod -R 777 ./mainnetdb)
    # optionally, you can mount a config.json into the container
    volumes:
      - ./mainnetdb/:/tmp/mainnetdb/:rw
      - ./config.json:/config.json:ro
    # Expose ports:
    # gossip:       - &quot;14666:14666/tcp&quot;
    # autopeering:  - &quot;14626:14626/udp&quot;
    # webAPI:       - &quot;8080:8080/tcp&quot;
    # dashboard:    - &quot;8081:8081/tcp&quot;
    ports:
      - &quot;14666:14666/tcp&quot;
      - &quot;14626:14626/udp&quot;
      - &quot;9311:9311/tcp&quot; # prometheus exporter
      - &quot;8080:8080/tcp&quot; # webApi
      - &quot;8081:8081/tcp&quot; # dashboard
</code></pre>
<h1 id="drng-api"><a class="header" href="#drng-api">dRNG API</a></h1>
<p>All the steps are described in the <a href="https://github.com/iotaledger/drng/wiki">dRNG wiki</a>.</p>
<h1 id="setting-up-monitoring-dashboard"><a class="header" href="#setting-up-monitoring-dashboard">Setting up Monitoring Dashboard</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>GoShimmer is shipped with its internal node dashboard that you can reach at <code>127.0.0.1:8081</code> by default. While this dashboard provides some basic metrics information, its main functionality is to provide a graphical interface to interact with your node.</p>
<p>Node operators who wish to have more insights into what is happening within their node have the option to enable a <a href="https://prometheus.io/">Prometheus</a> exporter plugin that gathers important metrics about their node. To visualize these metrics, a <a href="https://grafana.com/oss/grafana/">Grafana Dashboard</a> is utilized.</p>
<h1 id="setting-up-run-goshimmer-from-a-vps"><a class="header" href="#setting-up-run-goshimmer-from-a-vps">Setting up (run Goshimmer from a VPS)</a></h1>
<p>To enable the <strong>Monitoring Dashboard</strong> for a GoShimmer node running from a VPS as described <a href="tutorials/./setup.html">here</a>, you need to carry out some additional steps.</p>
<ol>
<li>Edit <code>docker-compose.yml</code>
TODO</li>
<li>Create Prometheus config.
TODO</li>
<li>Create Grafana config.
TODO</li>
<li>Run <code>docker-compose up</code>.
TODO</li>
</ol>
<h1 id="setting-up-run-goshimmer-from-your-home-machine"><a class="header" href="#setting-up-run-goshimmer-from-your-home-machine">Setting up (run Goshimmer from your home machine)</a></h1>
<p>Depending on how you run your GoShimmer node, there are different ways to set up the <strong>Monitoring Dashboard</strong>.</p>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<p>One of the easiest ways to run a node is to use <a href="https://www.docker.com/">Docker</a>. To automatically launch GoShimmer and the Monitoring Dashboard with docker, follow these steps:</p>
<ol>
<li><a href="https://docs.docker.com/get-docker/">Install docker</a>. On Linux, make sure you install both the <a href="https://docs.docker.com/engine/install/">Docker Engine</a> and <a href="https://docs.docker.com/compose/install/">Docker Compose</a>.</li>
<li>Clone the GoShimmer repository.
<pre><code class="language-bash">$ git clone git@github.com:iotaledger/goshimmer.git
</code></pre>
</li>
<li>Create a <code>config.json</code> from the provided <code>config.default.json</code>.
<pre><code class="language-bash">$ cd goshimmer
$ cp config.default.json config.json
</code></pre>
Make sure, that following entry is present in <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>From the root of the repo, start GoShimmer with:
<pre><code class="language-bash">$ docker-compose up
</code></pre>
</li>
</ol>
<p>You should be able to reach the Monitoring Dashboard via browser at <a href="http://localhost:3000">localhost:3000</a>. Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<p>After initial login, you will be prompted to change your password.
You can experiment with the dashboard, change layout, add panels and discover metrics. Your changes will be saved into a Grafana database located in the repo at <code>tools/monitoring/grafana/grafana.db</code>.</p>
<h2 id="binary"><a class="header" href="#binary">Binary</a></h2>
<p>If you run the <a href="https://github.com/iotaledger/goshimmer/releases">released binaries</a>, or build GoShimmer from source, you need to setup Prometheus and Grafana separately, furthermore, you have to configure GoShimmer to export data.</p>
<h3 id="goshimmer-configuration"><a class="header" href="#goshimmer-configuration">Goshimmer Configuration</a></h3>
<ol>
<li>Make sure that the <code>prometheus.bindAddress</code> config parameter is set in your <code>config.json</code>:
<pre><code class="language-json">  &quot;prometheus&quot;: {
    &quot;bindAddress&quot;: &quot;127.0.0.1:9311&quot;
  },
</code></pre>
</li>
<li>Make sure, that the <code>prometheus</code> plugin is enabled in your <code>config.json</code>:
<pre><code class="language-json">&quot;node&quot;: {
  &quot;disablePlugins&quot;: [],
  &quot;enablePlugins&quot;: [&quot;prometheus&quot;]
},
</code></pre>
</li>
</ol>
<h3 id="install-and-configure-prometheus"><a class="header" href="#install-and-configure-prometheus">Install and Configure Prometheus</a></h3>
<p>First, we take a look on how to configure and run Prometheus as a standalone application. Then, we setup a Linux system service that automatically runs Prometheus in the background.</p>
<h4 id="prometheus-as-standalone-app"><a class="header" href="#prometheus-as-standalone-app">Prometheus as Standalone App</a></h4>
<ol>
<li><a href="https://prometheus.io/download/">Download</a> the latest release of Prometheus for your system.</li>
<li>Unpack the downloaded file:
<pre><code class="language-bash">$ tar xvfz prometheus-*.tar.gz
$ cd prometheus-*
</code></pre>
</li>
<li>Create a <code>prometheus.yml</code> in the unpacked directory with the following content:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
</li>
<li>Start Prometheus from the unpacked folder:
<pre><code class="language-bash"># By default, Prometheus stores its database in ./data (flag --storage.tsdb.path).
$ ./prometheus --config.file=prometheus.yml
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<h4 id="prometheus-as-a-system-service-linux"><a class="header" href="#prometheus-as-a-system-service-linux">Prometheus as a System Service (Linux)</a></h4>
<p>Note: you have to have root privileges with your user to carry out the following steps.</p>
<ol>
<li>Create a Prometheus user, directories, and set this user as the owner of those directories.
<pre><code>$ sudo useradd --no-create-home --shell /bin/false prometheus
$ sudo mkdir /etc/prometheus
$ sudo mkdir /var/lib/prometheus
$ sudo chown prometheus:prometheus /etc/prometheus
$ sudo chown prometheus:prometheus /var/lib/prometheus
</code></pre>
</li>
<li>Download Prometheus source, extract and rename.
<pre><code>$ wget https://github.com/prometheus/prometheus/releases/download/v2.19.1/prometheus-2.19.1.linux-amd64.tar.gz
$ tar xvfz prometheus-2.19.1.linux-amd64.tar.gz
$ mv prometheus-2.19.1.linux-amd64.tar.gz prometheus-files
</code></pre>
</li>
<li>Copy Prometheus binaries to <code>/bin</code> and change their ownership
<pre><code>$ sudo cp prometheus-files/prometheus /usr/local/bin/
$ sudo cp prometheus-files/promtool /usr/local/bin/
$ sudo chown prometheus:prometheus /usr/local/bin/prometheus
$ sudo chown prometheus:prometheus /usr/local/bin/promtool
</code></pre>
</li>
<li>Copy Prometheus console libraries to <code>/etc</code> and change their ownership.
<pre><code>$ sudo cp -r prometheus-files/consoles /etc/prometheus
$ sudo cp -r prometheus-files/console_libraries /etc/prometheus
$ sudo chown -R prometheus:prometheus /etc/prometheus/consoles
$ sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries
</code></pre>
</li>
<li>Create Prometheus config file, define targets.
To create and open up the config file:
<pre><code>$ sudo nano /etc/prometheus/prometheus.yml
</code></pre>
Put the following content into the file:
<pre><code class="language-yaml">scrape_configs:
    - job_name: goshimmer_local
      scrape_interval: 5s
      static_configs:
      - targets:
        # goshimmer prometheus plugin export
        - 127.0.0.1:9311
</code></pre>
Save and exit the editor.</li>
<li>Change ownership of the config file.
<pre><code>$ sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
</code></pre>
</li>
<li>Create a Prometheus service file.
<pre><code>$ sudo nano /etc/systemd/system/prometheus.service
</code></pre>
Copy the following content into the file:
<pre><code class="language-yaml">[Unit]
Description=Prometheus GoShimmer Server
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
    --config.file /etc/prometheus/prometheus.yml \
    --storage.tsdb.path /var/lib/prometheus/ \
    --web.console.templates=/etc/prometheus/consoles \
    --web.console.libraries=/etc/prometheus/console_libraries

[Install]
WantedBy=multi-user.target
</code></pre>
</li>
<li>Reload <code>systemd</code> service to register the prometheus service.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start prometheus
</code></pre>
</li>
<li>Check if the service is running.
<pre><code>$ sudo systemctl status prometheus
</code></pre>
</li>
<li>You can access the prometheus server at <a href="http://localhost:9090">localhost:9090</a>.</li>
<li>(Optional) Prometheus server is running, but observe that <a href="http://localhost:9090/targets">localhost:9090/targets</a> shows the target being <code>DOWN</code>. Run GoShimmer with the configuration from the previous stage, and you will soon see the <code>goshimmer_local</code> target being <code>UP</code>.</li>
</ol>
<p>+1. When you want to stop the service, run:</p>
<pre><code>$ sudo systemctl stop prometheus
</code></pre>
<p>Prometheus now collects metrics from your node, but we need to setup Grafana to visualize the collected data.</p>
<h3 id="install-and-configure-grafana"><a class="header" href="#install-and-configure-grafana">Install and configure Grafana</a></h3>
<p>Head over to <a href="https://grafana.com/docs/grafana/latest/installation/">Grafana Documentation</a> and install Grafana. For Linux, the OSS Release is recommended.</p>
<h4 id="grafana-as-standalaon-app"><a class="header" href="#grafana-as-standalaon-app">Grafana as Standalaon App</a></h4>
<p>Depending on where you install Grafana from, the configuration directories will change. For clarity, we will proceed with the binary install here.</p>
<ol>
<li>
<p><a href="https://grafana.com/grafana/download">Download Grafana</a> binary and extract it into a folder.
For example:</p>
<pre><code class="language-bash">$ wget https://dl.grafana.com/oss/release/grafana-7.0.4.linux-amd64.tar.gz
$ tar -zxvf grafana-7.0.4.linux-amd64.tar.gz
</code></pre>
</li>
<li>
<p>We will need couple files from the GoShimmer repository. Here we suppose, that you have the repository directory <code>goshimmer</code> on the same level as the extracted <code>grafana-7.0.4</code> directory:</p>
<pre><code>├── grafana-7.0.4   
│   ├── bin       
│   ├── conf         
│   ├── LICENSE   
│   ├── NOTICE.md
│   ├── plugins-bundled
│   ├── public 
│   ├── README.md
│   ├── scripts 
│   └── VERSIO
├── goshimmer               
│   ├── CHANGELOG.md
│   ├── client             
│   ├── config.default.json
    ...
</code></pre>
<p>We copy a couple configuration files from the repository into Grafana's directory:</p>
<pre><code>$ cp -R goshimmer/tools/monitoring/grafana/dashboards/local_dashboard.json grafana-7.0.4/public/dashboards/
$ cp goshimmer/tools/monitoring/grafana/provisioning/datasources/datasources.yaml grafana-7.0.4/conf/provisioning/datasources/datasources.yaml
$ cp goshimmer/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml grafana-7.0.4/conf/provisioning/dashboards/dashboards.yaml
</code></pre>
</li>
<li>
<p>Run Grafana.</p>
<pre><code>$ cd grafana-7.0.4/bin
$ ./grafana-server
</code></pre>
</li>
<li>
<p>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</p>
</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-as-a-system-service-linux"><a class="header" href="#grafana-as-a-system-service-linux">Grafana as a System Service (Linux)</a></h4>
<p>Instead of running the <code>grafana-server</code> app each time we can create a service that runs in the background.</p>
<p>When you install Grafana from</p>
<ul>
<li><a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-from-apt-repository">APT repository</a> or <code>.deb</code> <a href="https://grafana.com/docs/grafana/latest/installation/debian/#install-deb-package">package</a> (Ubuntu or Debian),</li>
<li><a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-from-yum-repository">YUM repository</a> or <code>.rpm</code> <a href="https://grafana.com/docs/grafana/latest/installation/rpm/#install-with-rpm">package</a> (CentOS, Fedora, OpenSuse, RedHat),</li>
</ul>
<p>then Grafana is configured to run as a system service without any modification. All you need to do is copy config files from the GoShimmer repository:</p>
<ol>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/datasources/datasources.yaml">datasource yaml config</a> to <code>/etc/grafana</code>:
(assuming you are at the root of the cloned GoShimmer repository)
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/datasources/datasources.yaml /etc/grafana/provisioning/datasources
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml">dashboard yaml config</a> to <code>/etc/grafana</code>:
<pre><code>$ sudo cp tools/monitoring/grafana/provisioning/dashboards/dashboards.yaml /etc/grafana/provisioning/dashboards
</code></pre>
</li>
<li>Copy <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">Goshimmer Local Metrics</a> dashboard to <code>/var/lib/grafana/</code>:
<pre><code>$ sudo cp -R tools/monitoring/grafana/dashboards /var/lib/grafana/
</code></pre>
</li>
<li>Reload daemon and start Grafana.
<pre><code>$ sudo systemctl daemon-reload
$ sudo systemctl start grafana-server
</code></pre>
</li>
<li>Open Moitoring Dashboard at <a href="http://localhost:3000">localhost:3000</a>.</li>
</ol>
<p>Default login credentials are:</p>
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
<h4 id="grafana-config-via-gui"><a class="header" href="#grafana-config-via-gui">Grafana Config via GUI</a></h4>
<p>If you successfully installed Grafana and would like to set it up using its graphical interface, here are the steps you need to take:</p>
<ol>
<li>Run Grafana.</li>
<li>Open <a href="http://localhost:3000">localhost:3000</a> in a browser window.
Default login credentials are:
<ul>
<li><code>username</code> : admin</li>
<li><code>password</code> : admin</li>
</ul>
</li>
<li>On the left side, open <strong>Configuration -&gt; Data Sources</strong>. Click on <strong>Add data source</strong> and select <strong>Prometheus</strong> core plugin.</li>
<li>Fill the following fields:
<ul>
<li><code>URL</code>: http://localhost:9090</li>
<li><code>Scrape interval</code>: 5s</li>
</ul>
</li>
<li>Click on <strong>Save &amp; Test</strong>. If you have a running Prometheus server, everything should turn green. If the URL can't be reached, try changing the <strong>Access</strong> field to <code>Browser</code>.</li>
<li>On the left side panel, click on <strong>Dashboards -&gt; Manage</strong>.</li>
<li>Click on <strong>Import</strong>. Paste the content of <a href="https://github.com/iotaledger/goshimmer/blob/develop/tools/monitoring/grafana/dashboards/local_dashboard.json">local_dashboard.json</a> in the <strong>Import via panel json</strong>, or download the life and use the <strong>Upload .json file</strong> option.</li>
<li>Now you can open <strong>GoShimmer Local Metrics</strong> dashboard under <strong>Dashboards</strong>. Don't forget to start your node and run Prometheus!</li>
</ol>
<h1 id="application-logic"><a class="header" href="#application-logic">Application logic</a></h1>
<h1 id="protocol-high-level-overview"><a class="header" href="#protocol-high-level-overview">Protocol high-level overview</a></h1>
<p>To orientate the reader, we provide a high-level overview of the protocol, following the natural life cycle of a message. The first module used—while the message is still being created—, is the <strong>Tip Selection</strong>(ADD LINK) module. Here, the node must choose a certain number (from two to eight) of other messages to reference, meaning that the newly created message will be cryptographically attached to these referenced messages. An honest node must always choose tips uniformly at random from a tip pool, i.e., from a set of still unreferenced messages that satisfy a certain set of conditions, as discussed on INSERT LINK. In the diagram below, the issuance process being described now is represented in the context of the complete protocol. </p>
<p><img src="application_logic/Protocol_overview_own_message.png" alt="title" /></p>
<p>Each node in the network has limited bandwidth, CPU, and memory. In order to avoid any node from being overloaded, the right to write in everybody else's Tangle is regulated by the <strong>Rate and Congestion Control Module</strong>. The first one dictates the maximum rate of issuance of messages by the introduction of a small amount of proof of work. However, if an attacker accelerates the message issuance—effectively flooding the network—, the difficulty of the proof of work for that node will increase exponentially. Eventually, the attacker will be incapable of issuing new messages. </p>
<p>Later, the Congestion control module fairly allocates the network resources accordingly to a quantity called <strong>Access Mana</strong>, which acts as a <a href="https://en.wikipedia.org/wiki/Sybil_attack">Sybil protection</a> mechanism. The exact manner in which Access Mana is acquired is discussed in INSERT LINK. But—for the purposes of this overview—we can summarize Access Mana as a scarce resource, that makes an effective Sybil protection mechanism. Thus, each node has the right to issue messages at a rate proportional to their Access Mana. This fair rate is not constant (since the utilization of the network may fluctuate), and to correctly set its own individual rate of issuance of messages, each node uses a mechanism called the <strong>Rate Setter</strong>, that makes the average issuance rate of the node converge to the fair rate guaranteed by Access Mana. Nodes that do not use the rate Setter will be punished by either the Rate Control or the Congestion Control Module.</p>
<p>Between the Rate Setter and the actual gossip of the message, several steps will take place, but—for the sake of clearness—we ignore these steps for now and return to this subject later. Then, assuming that the message was properly created, it will be propagated to the rest of the network. Since we deal with a large number of nodes, the communication graph cannot be <a href="https://en.wikipedia.org/wiki/Complete_graph">complete</a>. Thus, the <a href="https://en.wikipedia.org/wiki/Network_topology">network topology</a> will be dictated by the <strong>Neighbor Selection</strong> (aka Auto-Peering) module, described in INSERT LINK. </p>
<p><img src="application_logic/Protocol_overview_received_message.png" alt="title" /></p>
<p>We turn our attention now to another point of view: the one of the nodes receiving new messages, represented in the diagram above. After receiving a message, the node will perform several <strong>syntactical verifications</strong>, that will act as a filter to the messages. Additionally, the message has to be <strong>solidified</strong>, meaning that the node must know all the past cone of the message (i.e., the set of all messages directly or indirectly referenced by the message in question). After this step, the node places all the messages left into an inbox (OUTBOX OR INBOX??). At a fixed global rate (meaning that all nodes use the same rate), the node uses a <strong>scheduler</strong> to choose a message from the inbox. This scheduler—that, technically, is part of the aforementioned congestion control mechanism—works as a gatekeeper, effectively regulating the use of the most scarce resources of the nodes. Since the scheduler works at a fixed rate, the network cannot be overwhelmed. As discussed in INSERT LINK, the scheduler is designed to ensure—even in the presence of attackers—the following properties:</p>
<ol>
<li><strong>Consistency</strong>: all honest nodes will schedule the same messages</li>
<li><strong>Fair access</strong>: the nodes' messages will be scheduled at a fair rate according to their Access Mana</li>
<li><strong>Bounded latency</strong>: the processing time of all messages will be bounded</li>
</ol>
<p>Only after passing the scheduler the messages can be written into the local Tangle. To do that, the nodes perform most of the <strong>semantic validation</strong>, such as the search for irreconcilable conflicts in the message's past cone or (in the case of value transfers) unlock condition checks. At this point (if the message passes these tests), the message will be <strong>booked</strong> into the <strong>local Tangle</strong> of the node. Additionally, in the case of a value transfer, the <strong>ledger state</strong> and two vectors called Access Mana Vector (already mentioned in this text) and <strong>Consensus Mana</strong> Vector are updated accordingly. The Consensus Mana is another Sybil protection mechanism which—since it is applied to different modules than Access Mana—has the need of a different calculation (for more details on that subject, see INSERT LINK). </p>
<p><img src="application_logic/Protocol_overview_booking.png" alt="title" /></p>
<p>After having the message booked, the node is free to <strong>gossip</strong> it, but a crucial step of the protocol is still missing: the <strong>Opinion Setter</strong> and the voting protocol, that deal with the most subjective parts of the consensus mechanism (notice that, until now, the protocol has mostly dealt with objective checks). The voting protocol used here is the FPC (or <strong>Fast Probabilistic Consensus</strong>), which is a binary voting protocol that allows a large group of nodes to come to a consensus on the value of a single bit. The FPC begins with each node having an initial opinion, set using the node's local time perception and ordering of the messages. The nodes must set opinions about two subjects: </p>
<ol>
<li><strong>The legitimacy of the timestamp of the message</strong>: Whenever a node issues a message, it adds a timestamp to it, which should represent the local time of issuance (as seen by the issuer node). The other nodes will judge if this timestamp is reasonable, by checking if it is too far away from their own local clock. The specific rule to do this check is described in LINK.</li>
<li>In the case of a value transfer, <strong>whether it is a conflict</strong>: We use the <strong>FCoB Rule</strong> (ADD LINK). Roughly, the node will have a positive opinion about a transaction A if and only if all its conflicts arrived later than a certain time interval after A's arrival. </li>
</ol>
<p>In each round, nodes randomly choose other nodes to query about their opinions about one of the subjects above. The querying node changes its own opinion if the number of responses with a different opinion than it is greater than a certain threshold. In order to prevent liveness attacks, this threshold is determined by a random number issued by a committee of high Consensus Mana nodes via the <strong>dRNG</strong> application. Without the random threshold, an attacker could lie about its responses in a way that could prevent the protocol from terminating. Finally, a node will finalize on a certain opinion after holding it for a certain number of rounds. </p>
<p>When selecting which other nodes to query, a node must weight the list of all nodes by Consensus Mana. Thus, high Consensus Mana nodes are queried more often than low Consensus Mana nodes. This makes it difficult for an attacker to manipulate the outcome of the voting. Unless the attacker controls more than 1/3 of the Consensus Mana in the system, with high probability, we know that FPC has the following properties:</p>
<ol>
<li><strong>Termination</strong>: every honest node will finalize on some opinion before a maximum round number.</li>
<li><strong>Agreement</strong>: all honest nodes will finalize on the same opinion.</li>
<li><strong>Integrity</strong>: if a super majority of nodes—e.g. more than 90% weighted by Consensus Mana—, have the same initial opinion, then FPC will terminate with that value.</li>
</ol>
<p><img src="application_logic/Protocol_overview_consensus.png" alt="title" /></p>
<p>Some concepts or modules implemented—even not strictly being part of the protocol—have an extreme importance in the understanding of the protocol as a whole, such as the <strong>Grades of Finality</strong> (add link). Analogously to Bitcoin's <a href="https://en.bitcoin.it/wiki/Confirmation">six blocks rule</a>, our protocol also has certain measures of the probability of a certain message being considered valid permanently by all nodes. The four possible grades are:</p>
<ol>
<li><strong>Grade 1</strong>: If 10 seconds have passed since the time the message arrived and no conflict was seen.</li>
<li><strong>Grade 2</strong>: If 20 seconds have passed since the time the message arrived and no conflict was seen.</li>
<li><strong>Grade 3</strong>: If the message achieved grade 2 and it accumulated enough approval weight (see LINK for more details)</li>
<li><strong>Grade 4</strong>: If the message achieved grade 3 and 30 minutes (??????????) have passed since the timestamp of the message</li>
</ol>
<p>For more details on the grades above, see LINK.</p>
<h1 id="implementation-design"><a class="header" href="#implementation-design">Implementation design</a></h1>
<h1 id="event-driven-model"><a class="header" href="#event-driven-model">Event driven model</a></h1>
<p>Event driven model is popular approach often used for example in GUI applications, where a program is waiting for some external event to take place (e.g. mouse click) in order to perform some action.
In case of GoShimmer there is no GUI, however it applies this architecture approach as it's really flexible and is used to handle communication with other nodes and other internal parts. 
In GoShimmer some of those events can be e.g. arrival of new tangle message, peering request or plugin start. 
When an event is triggered, an event handler (or a collection of handlers) is executed and the state of the application is updated as necessary.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary:</a></h2>
<p>At first let's define some terms used further to avoid misunderstandings:</p>
<ul>
<li>
<p>Event - represents the type of event (e.g. new message or peering request) as well as set of handlers and trigger functions. Each type of event is separately defined 
which means that events are independent of each other - each event has its own set of handlers and is triggered separately.</p>
</li>
<li>
<p>Event handler (callback) - is a function that is executed when an event of given type occurs. An event handler can accept multiple arguments (e.g. message ID or plugin) so that it can perform appropriate actions.
Every handler must accept the same set of parameters. Each event has a different set of handlers (there can be multiple handlers) that are executed when the event is triggered.</p>
</li>
<li>
<p>Trigger - is a method that triggers execution of event handlers with given parameter values.</p>
</li>
</ul>
<h2 id="creating-new-event-with-custom-callbacks"><a class="header" href="#creating-new-event-with-custom-callbacks">Creating new event with custom callbacks</a></h2>
<p>Below are the steps that show the example code necessary to create a custom event, attach a handler and trigger the event. </p>
<ol>
<li>Create a function that will call event handlers (handler caller) for a specific event. 
Each event has only one handler caller. It enforces that all handlers for the event must share the same interface, because the caller will pass a fixed set of arguments of specific types to handler function. 
It's not possible to pass different number of arguments or types to the handler function. 
Callers for all events must also share the same interface - the first argument represents the handler function that will be called represented by a generic argument.
Further arguments represent parameters that will be passed to the handler during execution. Below are example callers that accept one and two parameters respectively. 
More arguments can be passed in similar manner. </li>
</ol>
<pre><code class="language-go">func singleArgCaller(handler interface{}, params ...interface{}) {
    handler.(func (*Plugin))(params[0].(*Plugin))
}

func twoArgsCaller(handler interface{}, params ...interface{}) {
    handler.(func(*peer.Peer, error))(params[0].(*peer.Peer), params[1].(error))
}
</code></pre>
<p><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - this code seems a little complicated, so to make things simpler we will divide into smaller parts and explain each:</p>
<ul>
<li><code>handler.(func (*Plugin))</code> (A) - this part does type-cast the handler from generic type onto type of desired, specific function type - in this case it's a function that accepts <code>*Plugin</code> as its only parameter.</li>
<li><code>params[0].(*Plugin)</code> (B)- similarly to previous part, first element of parameter slice is type-casted onto <code>*Plugin</code> type, so that it matches the handler function interface.</li>
<li><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - the whole expression calls the type-casted handler function with the type-casted parameter value. We can also write this as <code>A(B)</code> to make things simpler.</li>
</ul>
<p>The above explanation also allows a better understanding of why all handlers must share the same interface - handler caller passes fixed number of parameters and does type-casting of arguments onto specific types.</p>
<ol start="2">
<li>Next, a new event object needs to be created. We pass the handler caller as an argument, which is saved inside the object to be called when the event is triggered.</li>
</ol>
<pre><code class="language-go">import &quot;github.com/iotaledger/hive.go/events&quot;

ThisEvent := events.NewEvent(singleArgCaller)
</code></pre>
<ol start="3">
<li>After creating the event, handlers (or callbacks) can be attached to it. An event can have multiple callbacks, however they all need to share the same interface. 
One thing to note, is that functions are not passed directly - first they are wrapped into a <code>events.Closure</code> object like in the example below. </li>
</ol>
<pre><code class="language-go">ThisEvent.Attach(events.NewClosure(func (arg *Plugin) {
    // do something
}))
</code></pre>
<ol start="4">
<li>In order to trigger the event with some parameters we need to run the <code>.Trigger</code> method on the event object with parameters that handler functions will receive:</li>
</ol>
<pre><code class="language-go">somePlugin Plugin
ThisEvent.Trigger(&amp;somePlugin)
</code></pre>
<h1 id="dependency-of-packages-and-plugins"><a class="header" href="#dependency-of-packages-and-plugins">Dependency of packages and plugins</a></h1>
<p>In GoShimmer, new features are added through the <a href="implementation_design/plugin.html">plugin system</a>.
When creating a new plugin, it must implement an interface shared with all other plugins, so it's easy to add new
plugins and change their internal implementation without worrying about compatibility. 
Because of this, to make the code clean and easily manageable the plugin's internal logic has to be implemented in a different package.
This is an example of an <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter design pattern</a> that is often used in plugin systems.
It's really useful in a prototype software like GoShimmer, because it's possible to easily switch between different implementations 
and internal interfaces just by using a different plugin, without having to rewrite the code using it. </p>
<p>When creating a new plugin, the logic should be implemented in a separate package stored in the <code>packages/</code> directory. 
The package should contain all struct and interface definitions used, as well as the specific logic. 
It should not reference any <code>plugin</code> packages from the <code>plugin/</code> directory as this could lead to circular dependencies between packages.</p>
<p>There are no special interfaces or requirements that packages in the <code>packages/</code> directory are forced to follow. However, they should be independent of other packages if possible, 
to avoid problems due to changing interfaces in other packages.</p>
<h1 id="plugin-system"><a class="header" href="#plugin-system">Plugin system</a></h1>
<p>GoShimmer is a complex application that is used in a research environment where requirements often changed and new ideas arise. 
The Plugin system allows to quickly and easily add and remove modules that need to be started. However, one thing that might be non-intuitive about the use of plugins is that it's taken to an extreme - everything is run through plugins. 
The only code that is not executed through a plugin system is the code responsible for configuring and starting the plugins.
All new future features added to the GoShimmer must be added by creating a new plugin. </p>
<h2 id="plugin-structure"><a class="header" href="#plugin-structure">Plugin structure</a></h2>
<p><code>Plugin</code> structure is defined as following.</p>
<pre><code class="language-go">type Plugin struct {
	Node   *Node
	Name   string
	Status int
	Events pluginEvents
	wg     *sync.WaitGroup
}
</code></pre>
<p>Below is a brief description of each field: </p>
<ul>
<li><code>Node</code> - contains a pointer to <code>Node</code> object which contains references to all the plugins and node-level logger. #TODO: figure out why it is there - not really used anywhere</li>
<li><code>Name</code> - descriptive name of the plugin.</li>
<li><code>Status</code> - flag indicating whether plugin is enabled or disabled.</li>
<li><code>Events</code> - structure containing events used to properly deploy the plugin. Details described below.</li>
<li><code>wg</code> - a private field containing WaitGroup. #TODO: figure out why it is there - not really used anywhere</li>
</ul>
<h2 id="plugin-events"><a class="header" href="#plugin-events">Plugin events</a></h2>
<p>Each plugin defines 3 events: <code>Init</code>, <code>Configure</code>, <code>Run</code>. 
Those events are triggered during different stages of node startup, but the plugin doesn't have to define handlers for all of those events in order to do what it's been designed for.
Execution order and purpose of each event is described below: </p>
<ol>
<li><code>Init</code> - is triggered almost immediately after a node is started. It's used in plugins that are critical for GoShimmer such as reading config file or initializing global logger. Most plugins don't need to use this event.</li>
<li><code>Configure</code> - this event is used to configure the plugin before it is started. It is used to define events related to internal plugin logic or initialize objects used by the plugin. </li>
<li><code>Run</code> - this event is triggered as the last one. The event handler function contains the main logic of the plugin. 
For many plugins, the event handler function creates a separate worker that works in the background, so that the handler function for one plugin can finish and allow other plugins to be started.</li>
</ol>
<p>Each event could potentially have more than one handler, however currently all existing plugins follow a convention where each event has only one handler.</p>
<p>It is important to note that each event is triggered for all plugins sequentially, so that the event <code>Init</code> is triggered for all plugins, then <code>Configure</code> is triggered for all plugins and finally <code>Run</code>. 
Such order is crucial, because some plugins rely on other plugins' initialization or configuration. The order in which plugins are initialized, configured and run is also important and this is described below. </p>
<p>Handler functions for all plugin events share the same interface, so they could potentially be used interchangeably. Sample handler functions look like this:</p>
<pre><code class="language-go">func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) { 
    // run plugin	
}
</code></pre>
<p>The handler functions receive one argument of type <code>*Plugin</code>. The code responsible for triggering those events passes a pointer to the plugin object itself. 
The object needs to be passed so that the handler function can access plugin fields (e.g. plugin name to configure logger).</p>
<h2 id="creating-new-plugin"><a class="header" href="#creating-new-plugin">Creating new plugin</a></h2>
<p>A plugin object can be created by calling the <code>node.NewPlugin</code> method. 
The method creates and returns a new plugin object, as well as registers it so that GoShimmer knows the plugin is available.
It accepts the following arguments:</p>
<ul>
<li><code>name string</code> - plugin name.</li>
<li><code>status int</code> - flag indicating whether plugin is enabled or disabled by default. This can be overridden by enabling/disabling the plugin in the external configuration file. Possible values: <code>node.Enabled</code>, <code>node.Disabled</code>. </li>
<li><code>callbacks ...Callback</code> - list of event handler functions. The method will correctly create a plugin when passing up to 2 callbacks. Note: <code>type Callback = func(plugin *Plugin)</code>, which is a raw function type without being wrapped in <code>events.Closure</code>.</li>
</ul>
<p>There is a couple of ways that the method can be called, depending on which plugin events need to be configured. </p>
<ul>
<li>Define <code>Configure</code> and <code>Run</code> event handlers. It's the most common usage that plugins currently use. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
</code></pre>
<ul>
<li>Define only <code>Configure</code> event. It's used for plugins that are used to configure objects used (or managed) by other plugins, such as creating API endpoints. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure)
</code></pre>
<ul>
<li>Define a plugin without <code>Configure</code> or <code>Run</code> event handlers. This is used to create plugins that perform some action when the <code>Init</code> event is triggered.</li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled)
</code></pre>
<p>However, the <code>Init</code> event handler cannot be attached using the <code>node.NewPlugin</code> method. 
In order to specify this handler, plugin creator needs to attach it manually to the event, for example inside the package's <code>init()</code> method in the file containing the rest of the plugin definition.</p>
<pre><code class="language-go">func init() {
	plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
		// do something
	}))
}
</code></pre>
<p>It's important to note, that the <code>node.NewPlugin</code> accepts handler functions in a raw format, that is, without being wrapped by the <code>events.Closure</code> object as the method does the wrapping inside.
However, when attaching the <code>Init</code> event handler manually, it must be wrapped by the <code>events.Closure</code> object. </p>
<p>It's crucial that each plugin is created only once and <code>sync.Once</code> class is used to guarantee that. Contents of a file containing sample plugin definition is presented. All plugins follow this format.</p>
<pre><code class="language-go">const PluginName = &quot;SamplePlugin&quot;

var (
	// plugin is the plugin instance of the new plugin plugin.
	plugin     *node.Plugin
	pluginOnce sync.Once
)

// Plugin gets the plugin instance.
func Plugin() *node.Plugin {
	pluginOnce.Do(func() {
		plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
	})
	return plugin
}

// Handler functions
func init() {
    plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
        // do something
    }))
}
func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) {
    // run stuff	
}
</code></pre>
<h2 id="running-new-plugin"><a class="header" href="#running-new-plugin">Running new plugin</a></h2>
<p>In order to correctly add a new plugin to GoShimmer, apart from defining it, it must also be passed to the <code>node.Run</code> method. 
Because there are plenty of plugins, in order to improve readability and make managing plugins easier, they are grouped into separate wrappers passed to the <code>node.Run</code> method. 
When adding a new plugin, it must be added into one of those groups, or a new group must be created.</p>
<pre><code class="language-go">node.Run(
    plugins.Core,
    plugins.Research,
    plugins.UI,
    plugins.WebAPI,
)
</code></pre>
<p>You can add a plugin simply by calling the <code>Plugin()</code> method of the newly created plugin and passing the argument further. An example group definition is presented below. When it's added, the plugin is correctly added and will be run when GoShimmer starts.</p>
<pre><code class="language-go">var Core = node.Plugins(
    banner.Plugin(),
    newPlugin.Plugin(),
    // other plugins ommited 
)
</code></pre>
<h2 id="background-workers"><a class="header" href="#background-workers">Background workers</a></h2>
<p>In order to run plugins beyond the scope of the short-lived <code>Run</code> event handler, possibly multiple <code>daemon.BackgroundWorker</code> instances can be started inside the handler function. 
This allows the <code>Run</code> event handler to finish quickly, and the plugin logic can continue running concurrently in a separate goroutine. </p>
<p>Background worker can be started by running the <code>daemon.BackgroundWorker</code> method, which accepts following arguments:</p>
<ul>
<li><code>name string</code> - background worker name</li>
<li><code>handler WorkerFunc</code> - long-running function that will be started in its own goroutine. It accepts a single argument of type <code>&lt;-chan struct{}</code>. When something is sent to that channel, the worker will shut down. Note: <code>type WorkerFunc = func(shutdownSignal &lt;-chan struct{})</code></li>
<li><code>order ...int</code> - value used to define in which shutdown order this particular background worker must be shut down (higher = earlier).
The parameter can either accept one or zero values, more values will be ignored. When passing zero values, default value of <code>0</code> is assumed.
Values are normalized in the <code>github.com/iotaledger/goshimmer/packages/shutdown</code> package, and it should be used instead of passing integers manually. 
Correct shutdown order is as important as correct start order, because different plugins depend on others working correctly, so when one plugin shuts down too soon, other plugins may run into errors, crash and leave an incorrect state. </li>
</ul>
<p>An example code for creating a background worker: </p>
<pre><code class="language-go">func start(shutdownSignal &lt;-chan struct{}) {
	// long-running function
	// possibly start goroutines here
	// wait for shutdown signal
    &lt;-shutdownSignal
}

if err := daemon.BackgroundWorker(backgroundWorkerName, start, shutdown.PriorityGossip); err != nil {
	log.Panicf(&quot;Failed to start as daemon: %s&quot;, err)
}
</code></pre>
<h1 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration parameters</a></h1>
<h2 id="customizing-configuration"><a class="header" href="#customizing-configuration">Customizing configuration</a></h2>
<p>Users can pass configuration parameters in two ways when running GoShimmer. One way is through a JSON configuration file and another way is through command line arguments.
Settings passed through command line arguments take precedence. The JSON configuration file is structured as a JSON object containing parameters and their values.
Parameters are grouped into embedded objects containing parameters for a single plugin or functionality. There is no limit on how deep the configuration object may be embedded.
For example, the config below contains example parameters for the PoW plugin.</p>
<pre><code class="language-json">{
  &quot;pow&quot;: {
    &quot;difficulty&quot;: 2,
    &quot;numThreads&quot;: 1,
    &quot;timeout&quot;: &quot;10s&quot;
  }
}
</code></pre>
<p>The same arguments can be passed through command line arguments in the following way. Embedded objects' values are described using JSON dot-notation.
Additionally,the user can pass the path of the JSON config file through a command-line argument as well, as shown in an example below. </p>
<pre><code class="language-bash">goshimmer \
--config=/tmp/config.json \
--pow.difficulty=2 \
--pow.numThreads=1 \
--pow.timeout=10s 
</code></pre>
<h2 id="custom-parameter-fields"><a class="header" href="#custom-parameter-fields">Custom parameter fields</a></h2>
<p>Currently, in the code there are two ways in which parameters are registered with GoShimmer. However, one is deprecated way, while the second should be used any longer when adding new parameters.</p>
<h3 id="old-deprecated-way"><a class="header" href="#old-deprecated-way">Old, deprecated way</a></h3>
<p>The old way is described shortly to give a basic understanding of how it works, but it should not be used any longer when adding new parameters.</p>
<p>In a package where the parameters will be used, create a <code>parameters.go</code> file, that contains the definition of constants, which define parameter names in JSON dot-notation. 
The constants will be later used in the code to access the parameter value. 
The file should also contain an <code>init()</code> function, which registers the parameters with the <code>flag</code> library responsible for parsing configuration along with its default value and short description.
It should include comments describing what the parameter is for. Here is an example <code>parameters.go</code> file:</p>
<pre><code class="language-go">package customPackage

import (
	flag &quot;github.com/spf13/pflag&quot;
)
const (
	// ParamName contains some value used within the plugin
	ParamName = &quot;customPlugin.paramName&quot;
)

func init() {
	flag.Float64(paramName, 0.31, &quot;ParamName used in some calculation&quot;)
}
</code></pre>
<p>The parameter values can be accessed in the code in the following way through the <code>config</code> plugin:</p>
<pre><code class="language-go">import &quot;github.com/iotaledger/goshimmer/plugins/config&quot;

config.Node().Int(CfgGossipPort)
</code></pre>
<h3 id="new-way"><a class="header" href="#new-way">New way</a></h3>
<p>Defining configuration parameters using the new way is really similar, however the parameters are not registered directly with the package reading the configuration,
but rather with our custom package that contains all the logic required to make it work seamlessly. </p>
<p>In this approach, instead of defining a parameter name, a new structure is defined with all necessary parameters, their default values and usage descriptions using Go's struct field tags.</p>
<p>One difference is that parameter names do not contain the namespace they belong to, the namespace is set when registering the parameters structure with the <code>configuration</code> package. One <code>parameters.go</code> file can contain definitions and register multiple parameter structures.</p>
<pre><code class="language-go">package customPlugin

import &quot;github.com/iotaledger/hive.go/configuration&quot;

// Parameters contains the configuration parameters used by the custom plugin.
var Parameters = struct {
	// ParamName contains some value used within the plugin
	ParamName float64 `default:&quot;0.31&quot; usage:&quot;ParamName used in some calculation&quot;`

	// ParamGroup contains an example of embedded configuration definitions.
	ParamGroup struct {
		// DetailedParam1 is the example value
		DetailedParam1        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam1 used in the plugin&quot;`
		// DetailedParam2 is the example value
		DetailedParam2        string `default:&quot;defaultValue&quot; usage:&quot;DetailedParam2 used in the plugin&quot;`
	}
}{}

func init() {
	configuration.BindParameters(&amp;Parameters, &quot;customPlugin&quot;)
}
</code></pre>
<p>In order to access the parameter value, a user can simply access the structure's field: <code>Parameters.ParamName</code> or <code>Parameters.ParamGroup.DetailedParam1</code> 
and it will be populated either with the default value or values passed through a JSON config or command-line argument. </p>
<p>This approach makes it more simple to define new parameters as well as makes accessing configuration values more clear. </p>
<h1 id="object-storage"><a class="header" href="#object-storage">Object storage</a></h1>
<p>In GoShimmer <code>ObjectStorage</code>  is used as a base data structure for many data collection elements such as <code>branchStorage</code>, <code>conflictStorage</code>, <code>messageStorage</code> and others.
It can be described by the following characteristics, it:</p>
<ul>
<li>is a manual cache which keeps objects in memory as long as consumers are using it</li>
<li>uses key-value storage type </li>
<li>provides mutex options for guarding shared variables and preventing changing the object state by multiple goroutines at the same time</li>
<li>takes care of  dynamic creation of different object types depending on the key, and the serialized data it receives through the utility <code>objectstorage.Factory</code></li>
<li>helps with the creation of multiple <code>ObjectStorage</code> instances from the same package and  automatic configuration.</li>
</ul>
<p>In order to create an object storage we need to provide the underlying <code>kvstore.KVStore</code> structure backed by the database.</p>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<p>GoShimmer stores data in the form of an object storage system. The data is stored in one large repository with flat structure. It is a scalable solution that allows for fast data retrieval because of its categorization structure.</p>
<p>Additionally, GoShimmer leaves the possibility to store data only in memory that can be specified with the parameter <code>CfgDatabaseInMemory</code> value. In-memory storage is purely based on a Go map, package <code>mapdb</code> from hive.go.
For the persistent storage in a database it uses package <code>badger</code> from hive.go. It is a simple and fast key-value database that performs well for both reads and writes simultaneously.</p>
<p>Both solutions are implemented in the <code>database</code> package, along with prefix definitions that can be used during the creation of new object storage elements.</p>
<p>The database plugin is responsible for creating a <code>store</code> instance of the chosen database under the directory specified with <code>CfgDatabaseDir</code> parameter. It will manage a proper closure of the database upon receiving a shutdown signal. During the start configuration, the database is marked as unhealthy, and it will be marked as healthy on shutdown. Then the garbage collector is run and the database can be closed.</p>
<h2 id="objectstorage"><a class="header" href="#objectstorage">ObjectStorage</a></h2>
<p>Assume we need to store data for some newly created object <code>A</code>. Then we need to define a new prefix for our package in the <code>database</code> package, and prefixes for single storage objects. They will be later used during <code>ObjectStorage</code> creation. A package prefix will be combined with a store specific prefix to create a specific realm.</p>
<pre><code class="language-Go">package example

type Storage struct {
	A                   *objectstorage.ObjectStorage
	...
	shutdownOnce        sync.Once
}
</code></pre>
<h3 id="objectstorage-factory"><a class="header" href="#objectstorage-factory">ObjectStorage factory</a></h3>
<p>To easily create multiple storage objects instances for one package, the most convenient way is to use the factory function.</p>
<pre><code class="language-Go">osFactory := objectstorage.NewFactory(store, database.Prefix)
</code></pre>
<p>It needs two parameters:</p>
<ul>
<li><code>store</code> - the key value <code>kvstore</code> instance</li>
<li><code>database.Prefix</code> - a prefix defined in the <code>database</code> package for our new <code>example</code> package. It will be responsible for automatic configuration of the newly provided <code>kvstore</code> instance.</li>
</ul>
<p>After defining the storage factory for the group of objects, we can use it to create an <code>*objectstorage.ObjectStorage</code> instance:</p>
<pre><code class="language-Go">AStorage = osFactory.New(objPrefix, FromObjectStorage)
AStorage = osFactory.New(objPrefix, FromObjectStorage, optionalOptions...)
</code></pre>
<p>For the function parameter we should provide:</p>
<ul>
<li><code>objPrefix</code> - mentioned before, we provide the object specific prefix.</li>
<li><code>FromObjectStorage</code> - a function that allows the dynamic creation of different object types depending on the stored data.</li>
<li><code>optionalOptions</code> -  an optional parameter provided in the form of options array <code>[]objectstorage.Option</code>. All possible options are defined in <code>objectstorage.Options</code>. If we do not specify them during creation, the default values will be used, such as enabled persistence or setting cache time to 0.</li>
</ul>
<h3 id="storableobject"><a class="header" href="#storableobject">StorableObject</a></h3>
<p><code>StorableObject</code> is an interface that allows the dynamic creation of different object types depending on the stored data. We need to make sure that all methods required by the interface are implemented to use the object storage factory.</p>
<ul>
<li><code>SetModified</code> - marks the object as modified, which will be written to the disk (if persistence is enabled).</li>
<li><code>IsModified</code> - returns true if the object is marked as modified</li>
<li><code>Delete</code> - marks the object to be deleted from the persistence layer</li>
<li><code>IsDeleted</code> - returns true if the object was marked as deleted</li>
<li><code>Persist</code> - enables or disables persistence for this object</li>
<li><code>ShouldPersist</code> - returns true if this object is going to be persisted</li>
<li><code>Update</code> - updates the object with the values of another object - requires an explicit implementation</li>
<li><code>ObjectStorageKey</code> - returns the key that is used to store the object in the database - requires an explicit implementation</li>
<li><code>ObjectStorageValue</code> - marshals the object data into a sequence of bytes that are used as the value part in the object storage - requires an explicit implementation</li>
</ul>
<p>Most of these have their default implementation in <code>objectstorage</code> library, except from <code>Update</code>, <code>ObjectStorageKey</code>, <code>ObjectStorageValue</code> which need to be provided.</p>
<h3 id="storableobjectfactory-function"><a class="header" href="#storableobjectfactory-function">StorableObjectFactory function</a></h3>
<p>The function <code>ObjectFromObjectStorage</code> from object storage provides functionality to restore objects from the <code>ObjectStorage</code>. By convention the implementation of this function usually follows the schema:
<code>ObjectFromObjectStorage</code> uses <code>ObjectFromBytes</code></p>
<pre><code class="language-Go">func ObjectFromObjectStorage(key []byte, data []byte) (result StorableObject, err error) {
    result, err := ObjectFromBytes(marshalutil.New(data))
    ...
    return
}
</code></pre>
<p><code>ObjectFromBytes</code> unmarshals the object sequence of bytes with a help of <code>marshalutil</code> library. The returned <code>consumedBytes</code> can be used for the testing purposes.
The created <code>marshalUtil</code> instance stores the stream of bytes and keeps track of what has been already read (<code>readOffset</code>).</p>
<pre><code class="language-Go">func ObjectFromBytes(bytes []byte) (object *ObjectType, consumedBytes int, err error) {
    marshalUtil := marshalutil.New(bytes)
    if object, err = ObjectFromMarshalUtil(marshalUtil); err != nil {
    ...
    consumedBytes = marshalUtil.ReadOffset()
    return
}
</code></pre>
<p>The key logic is implemented in <code>ObjectFromMarshalUtil</code> that takes the marshaled object and transforms it into the object of specified type.
Because the data is stored in a sequence of bytes, it has no information about the form of an object and any data types it had before writing to the database.
Thus, we need to serialize any data into a stream of bytes in order to write it (marshaling), and deserialize the stream of bytes back into correct data structures when reading it (unmarshaling). 
Let's consider as an example, unmarshaling of the <code>Approver</code> object.</p>
<pre><code class="language-Go">type Approver struct {
    approverType            ApproverType    //  8 bytes
    referencedMessageID     MessageID       // 32 bytes
    approverMessageID       MessageID       // 32 bytes
}
</code></pre>
<p>The order in which we read bytes has to reflect the order in which it was written down during marshaling. As in the example, the order: <code>referencedMessageID</code>, <code>approverType</code>, <code>approverMessageID</code> is the same in both marshalling and unmarshalling.</p>
<pre><code class="language-Go">// Unmarshalling
func ApproverFromMarshalUtil(marshalUtil *marshalutil.MarshalUtil) (result *Approver) {
    result = &amp;Approver{}
    result.referencedMessageID = MessageIDFromMarshalUtil(marshalUtil)
    result.approverType = ApproverTypeFromMarshalUtil(marshalUtil)
    result.approverMessageID = MessageIDFromMarshalUtil(marshalUtil)
    return
}
// Marshalling
func (a *Approver) ObjectStorageApprover() []byte {
    return marshalutil.New().
    Write(a.referencedMessageID).
    Write(a.approverType).
    Write(a.approverMessageID).
    Bytes()
}
</code></pre>
<p>We continue to decompose our object into smaller pieces with help of <code>MarshalUtil</code> struct that keeps track of bytes, and a read offset.
Then we use <code>marshalutil</code> build in methods on the appropriate parts of the byte stream with its length defined by the data
type of the struct field. This way, we are able to parse bytes to the correct Go data structure.</p>
<h3 id="objectstorage-methods"><a class="header" href="#objectstorage-methods">ObjectStorage methods</a></h3>
<p>After defining marshalling and unmarshalling mechanism for<code>objectStorage</code> bytes conversion, 
we can start using it for its sole purpose, to actually store and read the particular parts of the project elements. </p>
<ul>
<li>
<p><code>Load</code> allows retrieving the corresponding object based on the provided id. For example, the method on the message <code>objectStorage</code><br />
is getting the cached object. </p>
</li>
<li>
<p>To convert an object retrieved in the form of a cache to its own corresponding type, we can use <code>Unwrap</code>.
In the code below it will return the message wrapped by the cached object.</p>
</li>
<li>
<p><code>Exists</code> - checks weather the object has been deleted. If so it is released from memory with the <code>Release</code> method.</p>
<pre><code class="language-Go">func (s *Storage) Message(messageID MessageID) *CachedMessage {
    return &amp;CachedMessage{CachedObject: s.messageStorage.Load(messageID[:])}
}

cachedMessage := messagelayer.Tangle().Storage.Message(msgID)
if !cachedMessage.Exists() {
    msgObject.Release()
    }
message := cachedMessage.Unwrap()
</code></pre>
</li>
<li>
<p><code>Consume</code> will be useful when we want to apply a function on the cached object. <code>Consume</code> unwraps the <code>CachedObject</code> and passes a type-casted version to the consumer function.
Right after the object is consumed and when the callback is finished, the object is released.</p>
<pre><code class="language-Go">cachedMessage.Consume(func(message *tangle.Message) {
            doSomething(message)
        })
</code></pre>
</li>
<li>
<p><code>ForEach</code> - allows to apply a <code>Consumer</code> function for every object residing within the cache and the underlying persistence layer.
For example, this is how we can count the number of messages.</p>
<pre><code class="language-Go">messageCount := 0
messageStorage.ForEach(func(key []byte, cachedObject objectstorage.CachedObject) bool {
  	cachedObject.Consume(func(object objectstorage.StorableObject) {
  		messageCount++
      })
}
</code></pre>
</li>
<li>
<p><code>Store</code> - storing an object in the objectStorage. An extended version is method <code>StoreIfAbsent</code> 
that stores an object only if it was not stored before and returns boolean indication if the object was stored. 
<code>ComputeIfAbsent</code> works similarly but does not access the value log. </p>
<pre><code class="language-Go">cachedMessage := messageStorage.Store(newMessage)
cachedMessage, stored := messageStorage.StoreIfAbsent(newMessage)
cachedMessage := messageStorage.ComputeIfAbsent(newMessage, remappingFunction)
</code></pre>
</li>
</ul>
<h1 id="api"><a class="header" href="#api">API</a></h1>
<h1 id="client-lib-interaction-with-layers"><a class="header" href="#client-lib-interaction-with-layers">Client Lib: Interaction with layers</a></h1>
<blockquote>
<p>This guide is meant for developers familiar with the Go programming language.</p>
</blockquote>
<p>GoShimmer ships with a client Go library which communicates with the HTTP API. Please refer to the <a href="https://godoc.org/github.com/iotaledger/goshimmer/client">godoc.org docs</a> for function/struct documentation. There is also a set of APIs which do not directly have anything to do with the different layers. Since they are so simple, simply extract their usage from the GoDocs.</p>
<h1 id="use-the-api"><a class="header" href="#use-the-api">Use the API</a></h1>
<p>Simply <code>go get</code> the lib via:</p>
<pre><code>go get github.com/iotaledger/goshimmer/client
</code></pre>
<p>Init the API by passing in the API URI of your GoShimmer node:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;)
</code></pre>
<p>Optionally, define your own <code>http.Client</code> to use, in order for example to define custom timeouts:</p>
<pre><code>goshimAPI := client.NewGoShimmerAPI(&quot;http://mynode:8080&quot;, http.Client{Timeout: 30 * time.Second})
</code></pre>
<h4 id="a-note-about-errors"><a class="header" href="#a-note-about-errors">A note about errors</a></h4>
<p>The API issues HTTP calls to the defined GoShimmer node. Non 200 HTTP OK status codes will reflect themselves as <code>error</code> in the returned arguments. Meaning that for example calling for attachments with a non existing/available transaction on a node, will return an <code>error</code> from the respective function. (There might be exceptions to this rule)</p>
<h1 id="webapi---clientlib"><a class="header" href="#webapi---clientlib">WebAPI - clientLib</a></h1>
<p>The web API interface allows to access functionality of the node software via exposed http endpoints.</p>
<h2 id="how-to-use-the-api"><a class="header" href="#how-to-use-the-api">How to use the API</a></h2>
<p>The default port to access the web API is set to <code>8080:8080/tcp</code> in <code>docker-compose.yml</code>, where the first port number is the internal port number within the node software, and the second for the access from an http port. An example where these two would be set to different values, or the external port is not utilized, can be found in the docker-network tool (see also the <code>docker-compose.yml</code> file in the docker-network tool folder).</p>
<p>The server instance of the web API is contacted via <code>webapi.Server()</code>. Next we need to register a route with a matching handler.</p>
<pre><code>webapi.Server().ROUTE(path string, h HandlerFunc)
</code></pre>
<p>where <code>ROUTE</code> will be replaced later in this documentation by <code>GET</code> or <code>POST</code>. The <code>HandlerFunc</code> defines a function to serve HTTP requests that gives access to the Context</p>
<pre><code>func HandlerFunc(c Context) error
</code></pre>
<p>We can then use the Context to send a JSON response to the node: </p>
<pre><code>JSON(statuscode int, i interface{}) error
</code></pre>
<p>An implementation example is shown later for the POST method.</p>
<h2 id="get-and-post"><a class="header" href="#get-and-post">GET and POST</a></h2>
<p>Two methods are currently used. First, with <code>GET</code> we register a new GET route for a handler function. The handler is accessed via the address <code>path</code>. The handler for a GET method can set the node to perform certain actions.</p>
<pre><code>webapi.Server().GET(&quot;path&quot;, HandlerFunc)
```	
A command can be sent to the node software to the API, e.g. via command prompt: 
</code></pre>
<p>curl &quot;http://127.0.0.1:8080/path?command&quot;</p>
<pre><code>
$$ . $$

Second, with `POST` we register a new POST route for a handler function. The handler can receive a JSON body input and send specific messages to the tangle.
</code></pre>
<p>webapi.Server().POST(&quot;path&quot;, HandlerFunc)</p>
<pre><code>
For example, the following Handler `broadcastData` sends a data message to the tangle
</code></pre>
<p>func broadcastData(c echo.Context) error {
var request Request
if err := c.Bind(&amp;request); err != nil {
log.Info(err.Error())
return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}</p>
<pre><code>msg, err := messagelayer.IssuePayload(
	payload.NewGenericDataPayload(request.Data), messagelayer.Tangle())
if err != nil {
	return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}
return c.JSON(http.StatusOK, Response{ID: msg.ID().String()})
</code></pre>
<p>}</p>
<pre><code>As an example the JSON body   
</code></pre>
<p>{
&quot;data&quot;:&quot;HelloWor&quot;
}</p>
<pre><code>can be sent to `http://127.0.0.1:8080/data`, which will issue a data message containing &quot;HelloWor&quot; (note that in this  example the data input is size limited.)
 
</code></pre>
<h1 id="mana-api-methods"><a class="header" href="#mana-api-methods">Mana API Methods</a></h1>
<p>The mana APIs provide methods for people to retrieve the amount of access/consensus mana of nodes and outputs, as well as the event logs.</p>
<p>HTTP APIs:</p>
<ul>
<li><a href="apis/mana.html#mana">/mana</a></li>
<li><a href="apis/mana.html#manaall">/mana/all</a></li>
<li><a href="apis/mana.html#manapercentile">/mana/percentile</a></li>
<li><a href="apis/mana.html#manaaccessonline">/mana/access/online</a></li>
<li><a href="apis/mana.html#manaconsensusonline">/mana/consensus/online</a></li>
<li><a href="apis/mana.html#manaaccessnhighest">/mana/access/nhighest</a></li>
<li><a href="apis/mana.html#manaconsensusnhighest">/mana/consensus/nhighest</a></li>
<li><a href="apis/mana.html#manapending">/mana/pending</a></li>
<li><a href="apis/mana.html#manaconsensuspast">/mana/consensus/past</a></li>
<li><a href="apis/mana.html#manaconsensuslogs">/mana/consensus/logs</a></li>
<li><a href="apis/mana.html#valueallowedmanapledge">/value/allowedManaPledge</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/mana.html#getownmana">GetOwnMana()</a></li>
<li><a href="apis/mana.html#getmanafullnodeid">GetManaFullNodeID()</a></li>
<li><a href="apis/mana.html#getmana-with-short-node-id">GetMana with short node ID()</a></li>
<li><a href="apis/mana.html#client-lib---getallmana">GetAllMana()</a></li>
<li><a href="apis/mana.html#client-lib---getmanapercentile">GetManaPercentile()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineaccessmana">GetOnlineAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineconsensusmana">GetOnlineConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestaccessmana">GetNHighestAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestconsensusmana">GetNHighestConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getpending">GetPending()</a></li>
<li><a href="apis/mana.html#client-lib---getpastconsensusmanavector">GetPastConsensusManaVector()</a></li>
<li><a href="apis/mana.html#client-lib---getconsensuseventlogs">GetConsensusEventLogs()</a></li>
<li><a href="apis/mana.html#client-lib---getallowedmanapledgenodeids">GetAllowedManaPledgeNodeIDs()</a></li>
</ul>
<h2 id="mana"><a class="header" href="#mana"><code>/mana</code></a></h2>
<p>Get the access and consensus mana of the node.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>node ID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h4 id="note"><a class="header" href="#note"><strong>Note</strong></a></h4>
<p>If no node ID is given, it returns the access and consensus mana of the node you're communicating with.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="curl"><a class="header" href="#curl">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib"><a class="header" href="#client-lib">client lib</a></h4>
<p>There are 3 APIs to get mana of a node, which is based on the same HTTP API <code>/mana</code>.</p>
<h5 id="getownmana"><a class="header" href="#getownmana"><code>GetOwnMana</code></a></h5>
<p>Get the access and consensus mana of the node this API client is communicating with.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetOwnMana()
if err != nil {
    // return error
}

// print the node ID
fmt.Println(&quot;full ID: &quot;, manas.NodeID, &quot;short ID: &quot;, manas.ShortNodeID)

// get access mana of the node
fmt.Println(&quot;access mana: &quot;, manas.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)

// get consensus mana of the node
fmt.Println(&quot;consensus mana: &quot;, manas.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h5 id="getmanafullnodeid"><a class="header" href="#getmanafullnodeid"><code>GetManaFullNodeID</code></a></h5>
<p>Get Mana of a node with its full node ID.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetManaFullNodeID(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}
</code></pre>
<h5 id="getmana-with-short-node-id"><a class="header" href="#getmana-with-short-node-id"><code>GetMana</code> with short node ID</a></h5>
<pre><code class="language-go">manas, err := goshimAPI.GetMana(&quot;4AeXyZ26e4G&quot;)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-examples"><a class="header" href="#response-examples">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 26.5,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 26.5,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaall"><a class="header" href="#manaall"><code>/mana/all</code></a></h2>
<p>Get the mana perception of the node in the network. You can retrieve the full/short node ID, consensus mana, access mana of each node, and the mana updated time.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<h4 id="curl-1"><a class="header" href="#curl-1">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/all \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallmana"><a class="header" href="#client-lib---getallmana">client lib - <code>GetAllMana()</code></a></h4>
<pre><code class="language-go">manas, err := goshimAPI.GetAllMana()
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)

// get access mana of each node
for _, m := range manas.Access {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;access mana: &quot;, m.Mana)
}

// get consensus mana of each node
for _, m := range manas.Consensus {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-1"><a class="header" href="#response-examples-1">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;access&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;consensusTimestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>access</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr"><a class="header" href="#mananodestr"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapercentile"><a class="header" href="#manapercentile"><code>/mana/percentile</code></a></h2>
<p>To learn the top percentile the node belongs to relative to the network in terms of mana. The input should be a full node ID.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>node ID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<h4 id="curl-2"><a class="header" href="#curl-2">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/percentile?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getmanapercentile"><a class="header" href="#client-lib---getmanapercentile">client lib - <code>GetManaPercentile()</code></a></h4>
<pre><code class="language-go">mana, err := goshimAPI.GetManaPercentile(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana percentile: &quot;, mana.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana percentile: &quot;, mana.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h3 id="response-examples-2"><a class="header" href="#response-examples-2">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 75,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 75,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results-2"><a class="header" href="#results-2">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaaccessonline"><a class="header" href="#manaaccessonline"><code>/mana/access/online</code></a></h2>
<p>You can get a sorted list of online access mana of nodes, sorted from the highest access mana to the lowest. The highest access mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<h4 id="curl-3"><a class="header" href="#curl-3">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineaccessmana"><a class="header" href="#client-lib---getonlineaccessmana">client lib - <code>GetOnlineAccessMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineAccessMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;access mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-3"><a class="header" href="#response-examples-3">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-3"><a class="header" href="#results-3">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The access mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr"><a class="header" href="#onlinenodestr"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusonline"><a class="header" href="#manaconsensusonline"><code>/mana/consensus/online</code></a></h2>
<p>You can get a sorted list of online consensus mana of nodes, sorted from the highest consensus mana to the lowest. The highest consensus mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<h4 id="curl-4"><a class="header" href="#curl-4">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineconsensusmana"><a class="header" href="#client-lib---getonlineconsensusmana">client lib - <code>GetOnlineConsensusMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineConsensusMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-4"><a class="header" href="#response-examples-4">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-4"><a class="header" href="#results-4">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The consensus mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr-1"><a class="header" href="#onlinenodestr-1"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
</tbody></table>
<h2 id="manaaccessnhighest"><a class="header" href="#manaaccessnhighest"><code>/mana/access/nhighest</code></a></h2>
<p>You can get the N highest access mana holders in the network, sorted in descending order.
If N=0, all nodes that have access mana are returned sorted.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<h4 id="curl-5"><a class="header" href="#curl-5">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestaccessmana"><a class="header" href="#client-lib---getnhighestaccessmana">client lib - <code>GetNHighestAccessMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest access mana nodes
accessMana, err := goshimAPI.GetNHighestAccessMana(5)
if err != nil {
    // return error
}

for _, m := accessMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;access mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-5"><a class="header" href="#response-examples-5">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-5"><a class="header" href="#results-5">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest access mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-1"><a class="header" href="#mananodestr-1"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusnhighest"><a class="header" href="#manaconsensusnhighest"><code>/mana/consensus/nhighest</code></a></h2>
<p>You can get the N highest consensus mana holders in the network, sorted in descending order.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest consensus mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<h4 id="curl-6"><a class="header" href="#curl-6">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestconsensusmana"><a class="header" href="#client-lib---getnhighestconsensusmana">client lib - <code>GetNHighestConsensusMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest consensus mana nodes
consensusMana, err := goshimAPI.GetNHighestConsensusMana(5)
if err != nil {
    // return error
}

for _, m := consensusMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-6"><a class="header" href="#response-examples-6">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-6"><a class="header" href="#results-6">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest consensus mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-2"><a class="header" href="#mananodestr-2"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapending"><a class="header" href="#manapending"><code>/mana/pending</code></a></h2>
<p>Get the amount of base access mana that would be pledged if the given output was spent.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>outputID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The requesting output ID.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<h4 id="curl-7"><a class="header" href="#curl-7">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/pending?outputid=&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot; \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpending"><a class="header" href="#client-lib---getpending">client lib - <code>GetPending()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPending(&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;)
if err != nil {
    // return error
}

// get the amount of mana
fmt.Println(&quot;mana be pledged: &quot;, res.Mana)
fmt.Println(&quot;the timestamp of the output (decay duration)&quot;, res.Timestamp)
</code></pre>
<h3 id="response-examples-7"><a class="header" href="#response-examples-7">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;mana&quot;: 26.5,
  &quot;outputID&quot;: &quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;,  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-7"><a class="header" href="#results-7">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access base mana to be pledged.</td></tr>
<tr><td align="left"><code>outputID</code></td><td align="left">string</td><td align="left">The output ID of the request.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h2 id="manaconsensuspast"><a class="header" href="#manaconsensuspast"><code>/mana/consensus/past</code></a></h2>
<p>Get the consensus base mana vector of a time (int64) in the past.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>timestamp</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The timestamp of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>int64</td></tr>
</tbody></table>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<h4 id="curl-8"><a class="header" href="#curl-8">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/past?timestamp=1614924295 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpastconsensusmanavector"><a class="header" href="#client-lib---getpastconsensusmanavector">client lib - <code>GetPastConsensusManaVector()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPastConsensusManaVector(1614924295)
if err != nil {
    // return error
}

// the mana vector of each node
for _, m := range res.Consensus {
    fmt.Println(&quot;node ID:&quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-8"><a class="header" href="#response-examples-8">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;consensus&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5 
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-8"><a class="header" href="#results-8">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">The consensus mana of nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-3"><a class="header" href="#mananodestr-3"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensuslogs"><a class="header" href="#manaconsensuslogs"><code>/mana/consensus/logs</code></a></h2>
<p>Get the consensus event logs of the given node IDs.</p>
<h3 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>nodeIDs</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>A list of node ID of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>string array</td></tr>
</tbody></table>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<h4 id="curl-9"><a class="header" href="#curl-9">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/logs \
-X GET \
-H 'Content-Type: application/json'
-d '{
  &quot;nodeIDs&quot;: [
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux6&quot;
  ]
}'
</code></pre>
<h4 id="client-lib---getconsensuseventlogs"><a class="header" href="#client-lib---getconsensuseventlogs">client lib - <code>GetConsensusEventLogs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetConsensusEventLogs([]string{&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;})
if err != nil {
    // return error
}

for nodeID, e := range res.Logs {
    fmt.Println(&quot;node ID:&quot;, nodeID)
    
    // pledge logs
    for _, p := e.Pledge {
        fmt.Println(&quot;mana type: &quot;, p.ManaType)
        fmt.Println(&quot;node ID: &quot;, p.NodeID)
        fmt.Println(&quot;time: &quot;, p.Time)
        fmt.Println(&quot;transaction ID: &quot;, p.TxID)
        fmt.Println(&quot;mana amount: &quot;, p.Amount)
    }

    // revoke logs
    for _, r := e.Revoke {
        fmt.Println(&quot;mana type: &quot;, r.ManaType)
        fmt.Println(&quot;node ID: &quot;, r.NodeID)
        fmt.Println(&quot;time: &quot;, r.Time)
        fmt.Println(&quot;transaction ID: &quot;, r.TxID)
        fmt.Println(&quot;mana amount: &quot;, r.Amount)
        fmt.Println(&quot;input ID: &quot;, r.InputID)
    }
}
</code></pre>
<h3 id="response-examples-9"><a class="header" href="#response-examples-9">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;logs&quot;: [
      &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;: {
          &quot;pledge&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28
               }
          ],
          &quot;revoke&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28,
                  &quot;inputID&quot;: &quot;35P4cW9QfzHNjXJwZMDMCUxAR7F9mfm6FvPbdpJWudK2nBZ&quot;
              }
          ]
      }
  ],  
  &quot;startTime&quot;: 1614924295,
  &quot;endTime&quot;: 1614924300
}
</code></pre>
<h3 id="results-9"><a class="header" href="#results-9">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>logs</code></td><td align="left">map[string]*EventLogsJSON</td><td align="left">The consensus mana of nodes. The key of map is node ID.</td></tr>
<tr><td align="left"><code>startTime</code></td><td align="left">int64</td><td align="left">The starting time of collecting logs.</td></tr>
<tr><td align="left"><code>endTime</code></td><td align="left">int64</td><td align="left">The ending time of collecting logs.</td></tr>
</tbody></table>
<h4 id="eventlogsjson"><a class="header" href="#eventlogsjson"><code>EventLogsJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>pledge</code></td><td align="left">PledgedEventJSON</td><td align="left">Pledged event logs.</td></tr>
<tr><td align="left"><code>revoke</code></td><td align="left">RevokedEventJSON</td><td align="left">Revoked event logs.</td></tr>
</tbody></table>
<h4 id="pledgedeventjson"><a class="header" href="#pledgedeventjson"><code>PledgedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of pledged mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of pledged mana.</td></tr>
</tbody></table>
<h4 id="revokedeventjson"><a class="header" href="#revokedeventjson"><code>RevokedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of revoked mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of revoked mana.</td></tr>
<tr><td align="left"><code>inputID</code></td><td align="left">string</td><td align="left">The input ID of revoked mana.</td></tr>
</tbody></table>
<h2 id="valueallowedmanapledge"><a class="header" href="#valueallowedmanapledge"><code>/value/allowedManaPledge</code></a></h2>
<p>This returns the list of allowed mana pledge node IDs.</p>
<h3 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<h4 id="curl-10"><a class="header" href="#curl-10">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/value/allowedManaPledge \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallowedmanapledgenodeids"><a class="header" href="#client-lib---getallowedmanapledgenodeids">client lib - <code>GetAllowedManaPledgeNodeIDs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetAllowedManaPledgeNodeIDs()
if err != nil {
    // return error
}

// print the list of nodes that access mana is allowed to be pledged to
for _, id := range res.Access.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}

// print the list of nodes that consensus mana is allowed to be pledged to
for _, id := range res.Consensus.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}
</code></pre>
<h3 id="response-examples-10"><a class="header" href="#response-examples-10">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;accessMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
  &quot;consensusMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
}
</code></pre>
<h3 id="results-10"><a class="header" href="#results-10">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>accessMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge access mana.</td></tr>
<tr><td align="left"><code>consensusMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge consensus mana.</td></tr>
</tbody></table>
<h4 id="allowedpledge"><a class="header" href="#allowedpledge"><code>AllowedPledge</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>isFilterEnabled</code></td><td align="left">bool</td><td align="left">A flag shows that if mana pledge filter is enabled.</td></tr>
<tr><td align="left"><code>allowed</code></td><td align="left">[]string</td><td align="left">A list of node ID that allow to be pledged mana.</td></tr>
</tbody></table>
<p>The dRNG module provides API to retrieve both information on the committees as well as the latest randomness.</p>
<pre><code class="language-bash">curl --request GET \
  --url http://&lt;address&gt;:&lt;port&gt;/drng/info/committee
</code></pre>
<p>Should give a similar output:</p>
<pre><code class="language-json">{
  &quot;committees&quot;: [
    {
      &quot;instanceID&quot;: 1339,
      &quot;threshold&quot;: 4,
      &quot;identities&quot;: [
        &quot;GUdTwLDb6t6vZ7X5XzEnjFNDEVPteU7tVQ9nzKLfPjdo&quot;,
        &quot;68vNzBFE9HpmWLb2x4599AUUQNuimuhwn3XahTZZYUHt&quot;,
        &quot;Dc9n3JxYecaX3gpxVnWb4jS3KVz1K1SgSK1KpV1dzqT1&quot;,
        &quot;75g6r4tqGZhrgpDYZyZxVje1Qo54ezFYkCw94ELTLhPs&quot;,
        &quot;CN1XLXLHT9hv7fy3qNhpgNMD6uoHFkHtaNNKyNVCKybf&quot;,
        &quot;7SmttyqrKMkLo5NPYaiFoHs8LE6s7oCoWCQaZhui8m16&quot;,
        &quot;CypSmrHpTe3WQmCw54KP91F5gTmrQEL7EmTX38YStFXx&quot;
      ],
      &quot;distributedPK&quot;: &quot;901b0def227621364c784124cfa54a1e9b582a3867004511e6810307a8985ef84ff02541a9de4f30b8ff2d0b2972735c&quot;
    },
    {
      &quot;instanceID&quot;: 1,
      &quot;threshold&quot;: 3,
      &quot;identities&quot;: [
        &quot;AheLpbhRs1XZsRF8t8VBwuyQh9mqPHXQvthV5rsHytDG&quot;,
        &quot;FZ28bSTidszUBn8TTCAT9X1nVMwFNnoYBmZ1xfafez2z&quot;,
        &quot;GT3UxryW4rA9RN9ojnMGmZgE2wP7psagQxgVdA4B9L1P&quot;,
        &quot;4pB5boPvvk2o5MbMySDhqsmC2CtUdXyotPPEpb7YQPD7&quot;,
        &quot;64wCsTZpmKjRVHtBKXiFojw7uw3GszumfvC4kHdWsHga&quot;
      ],
      &quot;distributedPK&quot;: &quot;884bc65f1d023d84e2bd2e794320dc29600290ca7c83fefb2455dae2a07f2ae4f969f39de6b67b8005e3a328bb0196de&quot;
    }
  ]
}
</code></pre>
<pre><code class="language-bash">curl --request GET \
  --url http://&lt;address&gt;:&lt;port&gt;/drng/info/randomness
</code></pre>
<p>Should give a similar output:</p>
<pre><code class="language-json">{
  &quot;randomness&quot;: [
    {
      &quot;instanceID&quot;: 1,
      &quot;round&quot;: 489295,
      &quot;timestamp&quot;: &quot;2020-10-08T09:40:30.291940965Z&quot;,
      &quot;randomness&quot;: &quot;Dh62wImUx3zQ7sjZ6ulje+NvvPY1DYaUFrTmCP7gOWLQIHHcAF5o9bvRy0tanoHb3q3OlNHKO/DmpDc+SB6A1g==&quot;
    },
    {
      &quot;instanceID&quot;: 1339,
      &quot;round&quot;: 229624,
      &quot;timestamp&quot;: &quot;2020-10-08T09:40:30.253587073Z&quot;,
      &quot;randomness&quot;: &quot;EfQLVEwGlKrHhPAuZPd+JYXl19ZH03MW9m+D07UHjqnO/AuthbCYFY8AsVe4wu0s3P63HQ5N0dv5X+N5kvrIWw==&quot;
    }
  ]
}
</code></pre>
<h1 id="communication-layer-apis"><a class="header" href="#communication-layer-apis">Communication Layer APIs</a></h1>
<p>The communication layer represents the base Tangle layer where so called <code>Messages</code> are gossiped around. A <code>Message</code> contains payloads and it is up to upper layers to interpret and derive functionality out of them.</p>
<p>The API provides three functions to interact with this primitive layer:</p>
<ul>
<li><code>Data(data []byte) (string, error)</code></li>
<li><code>FindMessageByID(base58EncodedIDs []string) (*webapi_message.Response, error)</code></li>
<li><code>SendPayload(payload []byte) (string, error)</code></li>
</ul>
<h4 id="issuing-a-data-message"><a class="header" href="#issuing-a-data-message">Issuing a data message</a></h4>
<p>A data message is simply a <code>Message</code> containing some raw data (literally bytes). This type of message has therefore no real functionality other than that it is retrievable via <code>FindMessageByID</code>.</p>
<p>Example:</p>
<pre><code>messageID, err := goshimAPI.Data([]byte(&quot;Hello GoShimmer World&quot;))
</code></pre>
<p>Note that there is no need to do any additional work, since things like tip-selection, PoW and other tasks are done by the node itself.</p>
<h4 id="retrieve-messages"><a class="header" href="#retrieve-messages">Retrieve messages</a></h4>
<p>Of course messages can then be retrieved via <code>FindMessageByID()</code></p>
<pre><code>foundMsgs, err := goshimAPI.FindMessageByID([]string{base58EncodedMessageID})
if err != nil {
    // return error
}

// this might be nil if the message wasn't available
message := foundMsgs[0]
if message == nil {
    // return error
}

// will print &quot;Hello GoShimmer World&quot;
fmt.Println(string(message.Payload))
</code></pre>
<p>Note that we're getting actual <code>Message</code> objects from this call which represent a vertex in the communication layer Tangle. It does not matter what type of payload the message contains, meaning that <code>FindMessageByID</code> will also return messages which contain value objects or DRNG payloads.</p>
<h4 id="send-payload"><a class="header" href="#send-payload">Send Payload</a></h4>
<p><code>SendPayload()</code> takes a <code>payload</code> object of any type (data, value, drng, etc.) as a byte slice, issues a message with the given payload and returns its <code>messageID</code>. Note, that the payload must be valid, otherwise an error is returned.</p>
<p>Example:</p>
<pre><code class="language-go">helloPayload := payload.NewData([]byte{&quot;Hello Goshimmer World!&quot;})
messageID, err := goshimAPI.SendPayload(helloPayload.Bytes())
</code></pre>
<h1 id="value-layer-apis"><a class="header" href="#value-layer-apis">Value Layer APIs</a></h1>
<p>The value layer builds on top of the communication layer. It encapsulates the functionality of token transfers, ledger representation, conflict state and consensus via FPC.</p>
<p>Note that the value layer operates on <code>Value Objects</code> which is a payload type which is transferred via <code>Messages</code>. A <code>Value Object</code> encapsulates the transaction spending <a href="https://en.wikipedia.org/wiki/Unspent_transaction_output">UTXOs</a> to new outputs and references two other <code>Value Objects</code>. Please refer to <a href="apis/../concepts/layers.html">concepts &amp; layers</a> for a more in depth explanation of the value layer.</p>
<p>The API provides multiple functions to interact with the value layer and retrieve/issue the corresponding objects described above.</p>
<h4 id="retrieve-attachmentsvalue-objects"><a class="header" href="#retrieve-attachmentsvalue-objects">Retrieve attachments/value objects</a></h4>
<p>Attachments are <code>Value Objects</code> which reflect a vertex in the value layer Tangle. Note that a transaction can live in multiple <code>Value Objects</code> but one <code>Value Object</code> contains only one transaction.</p>
<p>You can retrieve all the <code>Value Objects</code> which attached a given transaction via <code>GetAttachments()</code>:</p>
<pre><code>attachments, err := goshimAPI.GetAttachments(base58EncodedTxID)
if err != nil {
    // return error
}

// print out the parents of the value object/attachment location
fmt.Println(attachments[0].ParentID0, attachments[0].ParentID1)
</code></pre>
<h4 id="retrieve-transactions"><a class="header" href="#retrieve-transactions">Retrieve transactions</a></h4>
<p>A transaction encapsulates the transfer from unspent transaction outputs to new outputs. </p>
<p>You can use <code>GetTransactionByID</code> to get a given transaction:</p>
<pre><code>tx, err := goshimAPI.GetAttachments(base58EncodedTxID)
if err != nil {
    // return error
}

// print transaction's confirmed state
inclState := tx.InclusionState
fmt.Printf(&quot;confirmation state: %v&quot;, inclState.Confirmed)

// print number of used UTXOs and created outputs
fmt.Println(&quot;inputs:&quot;, len(tx.Transaction.Inputs))
fmt.Println(&quot;outputs:&quot;, len(tx.Transaction.Outputs))
</code></pre>
<h4 id="send-transactions"><a class="header" href="#send-transactions">Send transactions</a></h4>
<p>Sending a transaction involves first creating a transaction object defining the UTXOs to consume and the definition of the outputs. In this example, we create a transaction spending the genesis output onto a new address:</p>
<pre><code>// create the output ID to reference as input in our transaction
genesisSeedBytes, _ := base58.Decode(&quot;7R1itJx5hVuo9w9hjg5cwKFmek4HMSoBDgJZN8hKGxih&quot;)
genesisWallet := wallet.New(genesisSeedBytes)
genesisAddr := genesisWallet.Seed().Address(0)
genesisOutputID := transaction.NewOutputID(genesisAddr, transaction.GenesisID)

// receiver
receiverWallet := wallet.New()
destAddr := receiverWallet.Seed().Address(0)

// create the transaction
tx := transaction.New(
    transaction.NewInputs(genesisOutputID),
    transaction.NewOutputs(map[address.Address][]*balance.Balance{
        destAddr: {
            {Value: genesisBalance, Color: balance.ColorIOTA},
        },
}))

// sign it
tx = tx.Sign(signaturescheme.ED25519(*genesisWallet.Seed().KeyPair(0)))

// issue it
txID, err := goshimAPI.SendTransaction(tx.Bytes())
if err != nil {
    // return error
}

// base58 transaction hash: 9TtYfSP7Y3ipQBQVWVKeunKVMyxgVfGRXLkEZ6kLR1mP
fmt.Println(txID)
</code></pre>
<p>Note that the node will perform tip-selection and therefore decide the attachment location of the <code>Value Object</code> encapsulating the transaction.</p>
<h4 id="retrieve-utxosbalances"><a class="header" href="#retrieve-utxosbalances">Retrieve UTXOs/balances</a></h4>
<p>The balances of an address are made up from the UTXOs residing on that address. A balance is an amount of tokens and their corresponding color. A UTXO may contain multiple balances with different colors.</p>
<p>Lets retrieve the UTXO of the transaction we issued above:</p>
<pre><code>utxos, err := goshimAPI.GetUnspentOutputs([]string{destAddr.String()})
if err != nil {
    // return error
}

// get the balance of the first UTXO
outputs := utxos.UnspentOutputs[0]
output := outputs.OutputIDs[0]
fmt.Printf(&quot;output %s has a balance of %d\n&quot;, output.ID, output.Balances[0].Value)

// UTXOs also have inclusion states
if output.InclusionState.Confirmed {
    fmt.Printf(&quot;the balance of output %s is confirmed\n&quot;, output.ID)
}

</code></pre>
<p>Note that normally you should interact with UTXOs through a higher level of abstraction since most use cases evolve around things like getting the total confirmed balance, spendable inputs etc., which can be cumbersome when  operating directly on UTXOs.</p>
<h4 id="coloring-tokens"><a class="header" href="#coloring-tokens">Coloring tokens</a></h4>
<p>As an issuer of a transaction, you're free to color all the tokens of the inputs you spend to a new color of tokens. Note again, that a balance is an amount of tokens and a color. </p>
<p>In order to color tokens, we declare in our output the color of the balance to be of type <code>balance.ColorNew</code>. When we declare <code>balance.ColorNew</code>, the node is instructed to set the color of the balance to be equal to the hash of the transaction in which the output is created.</p>
<p>Taking the example from above where we spend the genesis output, we just need to make a minor adjustment to create new colored tokens:</p>
<pre><code>tx := transaction.New(
    transaction.NewInputs(genesisOutputID),
    transaction.NewOutputs(map[address.Address][]*balance.Balance{
        destAddr: {
            {Value: genesisBalance, Color: balance.ColorNew},
        },
}))
</code></pre>
<p>The color will then be equivalent to the transaction ID.</p>
<p>Note that coloring tokens doesn't increase/decrease the supply of tokens by any means. It merely colors the tokens and it is up to applications to interpret their intend.</p>
<h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<h1 id="docker-private-network"><a class="header" href="#docker-private-network">Docker private network</a></h1>
<p>We provide a tool at <code>tools/docker-network</code> with which a local test network can be set up locally with docker. </p>
<p><img src="tooling/../../images/docker-network.png" alt="Docker network" /></p>
<h2 id="how-to-use-the-tool"><a class="header" href="#how-to-use-the-tool">How to use the tool</a></h2>
<p>In the docker network run for example</p>
<pre><code>./run.sh 5 1 1
</code></pre>
<p>The command <code>./run.sh</code> spins up a GoShimmer network within Docker as schematically shown in the figure above. The first integer input defines the number of <code>peer_replicas</code> <code>N</code>. The second argument is optional for activating the Grafana dashboard, where </p>
<ul>
<li>default (no argument) or 0: Grafana disabled</li>
<li>1: Grafana enabled</li>
</ul>
<p>More details on how to set up the dashboard can be found <a href="tooling/../tutorials/setup.html">here</a>.</p>
<p>The third argument is optional for activating a dRNG committee, where</p>
<ul>
<li>default (no argument) or 0: dRNG disabled</li>
<li>1: dRNG enabled</li>
</ul>
<p>The peers can communicate freely within the Docker network 
while the analysis and visualizer dashboard, as well as the <code>master_peer's</code> dashboard and web API are reachable from the host system on the respective ports.</p>
<p>The settings for the different containers (<code>entry_node</code>, <code>peer_master</code>, <code>peer_replica</code>) can be modified in <code>docker-compose.yml</code>.</p>
<h2 id="how-to-use-as-development-tool"><a class="header" href="#how-to-use-as-development-tool">How to use as development tool</a></h2>
<p>Using a standalone throwaway Docker network can be really helpful as a development tool. </p>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<p>Reachable from the host system</p>
<ul>
<li>analysis dashboard (autopeering visualizer): http://localhost:9000</li>
<li><code>master_peer's</code> dashboard: http: http://localhost:8081</li>
<li><code>master_peer's</code> web API: http: http://localhost:8080</li>
</ul>
<p>It is therefore possible to send messages to the local network via the <code>master_peer</code>. Log messages of a specific containter can be followed via </p>
<pre><code>docker logs --follow CONTAINERNAME
</code></pre>
<h2 id="how-to-use-message-approval-check-tool"><a class="header" href="#how-to-use-message-approval-check-tool">How to use message approval check tool</a></h2>
<p><code>get_approval_csv.sh</code> script helps you conveniently trigger the message approval checks on all nodes in the docker
network, and gather their results in the <code>csv</code> folder.</p>
<p>Once the network is up and running, execute the script:</p>
<pre><code>./get_approval_csv.sh
</code></pre>
<p>Example output:</p>
<pre><code>Triggering approval analysis on peer_master and 20 replicas...
Triggering approval analysis on peer_master and 20 replicas... DONE
Copying csv files from peer_master and 20 replicas...
Copying csv files from peer_master and 20 replicas... DONE
Copied files are located at ./csv
</code></pre>
<p>The exported csv files are timestamped to the date of request.</p>
<pre><code>csv
├── 210120_16_34_14-docker-network_peer_replica_10.csv
├── 210120_16_34_14-docker-network_peer_replica_11.csv
├── 210120_16_34_14-docker-network_peer_replica_12.csv
...
</code></pre>
<p>Note, that the record length of the files might differ, since the approval check execution time of the nodes might differ.</p>
<h2 id="spammer-tool"><a class="header" href="#spammer-tool">Spammer tool</a></h2>
<p>The Spammer tool lets you add messages to the tangle when running GoShimmer in a Docker network.
In order to start the spammer, you need to send GET requests to a <code>/spammer</code> API endpoint with the following parameters:</p>
<ul>
<li><code>cmd</code> - one of two possible values: <code>start</code> and <code>shutdown</code>.</li>
<li><code>mpm</code> - messages per minute. Only applicable when <code>cmd=start</code>. </li>
<li><code>imif</code> - (<em>optional</em>) parameter indicating time interval between issued messages. Possible values:
<ul>
<li><code>poisson</code> - emit messages modeled with Poisson point process, whose time intervals are exponential variables with mean 1/rate</li>
<li><code>uniform</code> - issues messages at constant rate</li>
</ul>
</li>
</ul>
<p>Example requests:</p>
<pre><code class="language-bash">http://localhost:8080/spammer?cmd=start&amp;mpm=1000

http://localhost:8080/spammer?cmd=start&amp;mpm=1000&amp;imif=uniform
http://localhost:8080/spammer?cmd=shutdown
</code></pre>
<h2 id="tangle-width"><a class="header" href="#tangle-width">Tangle width</a></h2>
<p>When running GoShimmer locally in a Docker network, the network delay is so small that only 1 tip will be available most of the time. 
In order to artificially create a tangle structure with multiple tips you can add a <code>messageLayer.tangleWidth</code> property to <a href="tooling/tools/docker-network/config.docker.json">config.docker.json</a>
that specifies the number of tips that nodes should retain. This setting exists only for local testing purposes and should not be used in a distributed testnet.</p>
<p>Here is an example config that can be added: </p>
<pre><code class="language-json">  &quot;messageLayer&quot;: {
    &quot;tangleWidth&quot;: 10
  },
</code></pre>
<h1 id="integration-tests-with-docker"><a class="header" href="#integration-tests-with-docker">Integration tests with Docker</a></h1>
<p><img src="tooling/../../images/integration-testing.png" alt="Integration testing" /></p>
<p>Running the integration tests spins up a <code>tester</code> container within which every test can specify its own GoShimmer network with Docker as schematically shown in the figure above.</p>
<p>Peers can communicate freely within their Docker network and this is exactly how the tests are run using the <code>tester</code> container.
Test can be written in regular Go style while the framework provides convenience functions to create a new network, access a specific peer's web API or logs.</p>
<h2 id="how-to-run"><a class="header" href="#how-to-run">How to run</a></h2>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<pre><code># Mac &amp; Linux
cd tools/integration-tests
./runTests.sh
</code></pre>
<p>The tests produce <code>*.log</code> files for every networks' peer in the <code>logs</code> folder after every run.</p>
<p>On GitHub logs of every peer are stored as artifacts and can be downloaded for closer inspection once the job finishes.</p>
<h2 id="creating-tests"><a class="header" href="#creating-tests">Creating tests</a></h2>
<p>Tests can be written in regular Go style. Each tested component should reside in its own test file in <code>tools/integration-tests/tester/tests</code>.
<code>main_test</code> with its <code>TestMain</code> function is executed before any test in the package and initializes the integration test framework.</p>
<p>Each test has to specify its network where the tests are run. This can be done via the framework at the beginning of a test.</p>
<pre><code class="language-go">// create a network with name 'testnetwork' with 6 peers and wait until every peer has at least 3 neighbors
n := f.CreateNetwork(&quot;testnetwork&quot;, 6, 3)
// must be called to create log files and properly clean up
defer n.Shutdown() 
</code></pre>
<h2 id="other-tips"><a class="header" href="#other-tips">Other tips</a></h2>
<p>Useful for development is to only execute the test you're currently building. For that matter, simply modify the <code>docker-compose.yml</code> file as follows:</p>
<pre><code class="language-yaml">entrypoint: go test ./tests -run &lt;YOUR_TEST_NAME&gt; -v -mod=readonly
</code></pre>
<h1 id="specification-of-implementation"><a class="header" href="#specification-of-implementation">Specification of Implementation</a></h1>
<h1 id="mana-implementation"><a class="header" href="#mana-implementation">Mana Implementation</a></h1>
<p>This document provides a high level overview of how mana is implemented in GoShimmer.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Mana is a reputation system for nodes within the IOTA network.</p>
<p>Reputation is gained by contributing to the network, i.e. creating value transfers.
As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The scope of the first implementation of mana into GoShimmer is to verify that mana calculations work,
study base mana calculations 1 &amp; 2, and mana distribution in the test network, furthermore to verify that nodes have
similar view on the network.</p>
<h2 id="mana-calculation"><a class="header" href="#mana-calculation">Mana Calculation</a></h2>
<p>Mana is essentially the reputation score of a node in the IOTA network. Mana is calculated locally in each node, as a
function that takes value transactions as input and produces the Base Mana Vector as output.</p>
<p>Each transaction has an <code>accessMana</code> and <code>consensusMana</code> field that determine which node to pledge these two types
of mana to. Both of these fields denote a <code>nodeID</code>, the receiver of mana. <code>accessMana</code> and <code>consensusMana</code> do not have
to be pledged to the same node, but for simplicity, in the first implementation, they will be.</p>
<p>In addition to the mana fields, a <code>timestamp</code> field is also added to the transactions that will be utilized for calculating
decay and effective mana.</p>
<p>From the pledged mana of a transaction, a node can calculate locally the <code>Base Mana Vector</code> for both <code>Access Mana</code> and
<code>Consensus Mana</code>.</p>
<p>A <code>Base Mana Vector</code> consists of Base Mana 1 and Base Mana 2 and their respective <code>Effective Base Mana</code>.
Given a value transaction, Base Mana 1 and Base Mana 2 are determined as follows:</p>
<ol>
<li>Base Mana 1 is revoked from the node that created the output(s) used as input(s) in the transaction, and is pledged to
the node creating the new output(s). The amount of <code>Base Mana 1</code> revoked and pledged is equal to the balance of the
input.</li>
<li>Base Mana 2 is freshly created at the issuance time of the transaction, awarded to the node, but decays with time.
The amount of <code>Base Mana 2</code> pledged is determined with <code>Pending Mana</code> concept: funds sitting at an address generate
<code>pending mana</code> that grows over time, but bounded.
<ul>
<li><code>Mana_pending = (alpha*S)/gamma*(1-e^(-gamma*t))</code>, where <code>alpha</code> and <code>gamma</code> are chosen parameters, <code>S</code> is the amount
of funds an output transfers to the address, and <code>t</code> is the time since the funds are on that address.</li>
</ul>
</li>
</ol>
<p>An example <code>Base Mana Vector</code> for <code>Access Mana</code> could look like this:</p>
<p>| 		    | Node 1 | Node 2 | ... | Node k
|  ------- | --------- | ---------- | ------ | ---
| Base Mana 1 			|0	| 1 	|...|  100.54
| Effective Base Mana 1	|0	| 0.5 	|...|  120.7
| Base Mana 2 			|0	| 1.2	|...|  0.01
| Effective Base Mana 2	|0	| 0.6 	|...|  0.015</p>
<p><code>Base Mana</code> is pledged or revoked at discrete times, which results in <code>Base Mana</code> being discontinuous function over time.
In order to make mana &quot;smoother&quot; and continuous, an exponential moving average is applied to the <code>Base Mana</code> values,
resulting in <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code>.</p>
<p>It is important to note, that consuming a new transaction and pledging its mana happens when the transaction is
confirmed on the node. At the same time, entries of the nodes whose mana is being modified during pledging in the
<code>Base Mana Vector(s)</code> are updated with respect to time. In general, updates due to time happen whenever a node's mana is
being accessed. Except for the aforementioned case, this could be for example a mana related query from an external
module (FPC, Autopeering, DRNG, Rate Control, tools, etc.).</p>
<p>Following figure summarizes how <code>Access Mana</code> and <code>Consensus Mana</code> is derived from a transaction:</p>
<p><img src="https://i.imgur.com/LjfCTm9.png" alt="" /></p>
<p>The reason for having two separate <code>Base Mana Vectors</code> is the fact, that <code>accessMana</code> and <code>consensusMana</code> can be pledged
to different nodes.</p>
<p>The exact mathematical formulas, and their respective parameters will be determined later.</p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<h3 id="dependency-on-tangle"><a class="header" href="#dependency-on-tangle">Dependency on Tangle</a></h3>
<p>Since mana is awarded to nodes submitting value transfers, the tangle is needed as input for mana calculation.
Each node calculates mana locally, therefore, it is essential to determine when to consider transactions in the
tangle &quot;final enough&quot; (so that they will not be orphaned).</p>
<p>When a transaction is <code>confirmed</code>, it is a sufficient indicator that it will not be orphaned. However, in current
GoShimmer implementation, confirmation is not yet a properly defined concept. This issue will be addressed in a separate
module.</p>
<p>The Mana module assumes, that the (value) tangle's <code>TransactionConfirmed</code> event is the trigger condition to update the
mana state machine (base mana vectors for access and consensus mana). Once the concept of transaction finality is
introduced for the tangle, the trigger conditions for access and consensus mana calculations can be adjusted.</p>
<h3 id="transaction-layout"><a class="header" href="#transaction-layout">Transaction Layout</a></h3>
<p>A new field should be added to <code>Transaction</code> denoting <code>PledgedNodeID</code> for <code>Access Mana</code> and <code>Consensus Mana</code>.
This is also beneficial to implement mana donation feature, that is, to donate the mana of a certain transaction to an
arbitrary node.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The first implementation of mana in GoShimmer will:</p>
<ul>
<li>not have voted timestamps on value transactions,</li>
<li>lack proper <code>TransactionConfirmed</code> mechanism to trigger mana update,</li>
<li>lack integration into rate control/autopeering/fpc/etc.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>In this section, detailed GoShimmer implementation design considerations will be outlined about the mana module.
In short, changes can be classified into 3 categories:</p>
<ol>
<li>Transaction related changes,</li>
<li>Mana module functionality,</li>
<li>and related tools/utilities, such as API, visualization, analytics.</li>
</ol>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>As described above, 3 new fields will be added to the transaction layout:</p>
<ol>
<li><code>Timestamp</code> time.time</li>
<li><code>AccessManaNodeID</code> []bytes</li>
<li><code>ConsensusManaNodeID</code> []bytes</li>
</ol>
<p>By adding these fields to the signed transaction, <code>valuetransfers/packages/transaction</code> should be modified.</p>
<ul>
<li>The three new fields should be added to the transaction essence.</li>
<li>Marshalling and unmarshalling of a transaction should be modified.</li>
<li>For calculating <code>Base Mana 1</code> values, <code>mana module</code> should be able to derive from a transaction the nodes which received
pledged <code>Base Mana 1</code> as a consequence of the consumed inputs of the transaction. Therefore, a lookup function should
be exposed from the value tangle that given an <code>input</code>, returns the <code>pledgedNodeID</code> of the transaction creating the input.</li>
</ul>
<p><code>Timestamp</code> is part of the signed transaction, therefore, a client sending a transaction to the node should already
define it. In this case, this <code>Timestamp</code> will not be the same as the timestamp of the message containing the
transaction and value payload, since the message is created on the node.
A solution to this is that upon receiving a <code>transaction</code> from a client, the node checks if the timestamp is within
a predefined time window, for example <code>t_current - delta</code>, where <code>delta</code> could be couple seconds. If true, then the node
constructs the message, which must have a greater timestamp, than the transaction.</p>
<p><code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are also part of the signed transaction, so a client should fill them out.
Node owners are free to choose to whom they pledge mana to with the transaction, so there should be a mechanism that
lets the client know, what <code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are allowed. This could be a new API endpoint
that works like this:</p>
<ol>
<li>Client asks node what nodeIDs can be included for pledging  a certain type (access, consensus) mana.</li>
<li>Node answers with either:</li>
</ol>
<ul>
<li>Don't care. Any node IDs are valid.</li>
<li>List of nodeIDs that are allowed for each type.</li>
</ul>
<ol start="3">
<li>If a client sends back the transaction with invalid or empty mana fields, the transaction is considered invalid.</li>
</ol>
<p>This way node owners can decide who their transactions are pledging mana to. It could be only their node, or they could
provide mana pledging as a service. They could delegate access mana to others, but hold own to consensus mana, or the
other way around.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception
of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together
with the ledger state, base mana vectors are also saved, since a certain ledger state reflects a certain mana distribution
in the network. In future, when snapshotting is implemented in GoShimmer, nodes joining the network will be able to query
for snapshot files that will contain initial base mana vectors as well.</p>
<p>Until this functionality is implemented, mana calculation solely relies on transactions getting confirmed. That is, when
a node joins the network and starts gathering messages and transactions from peers, it builds its own ledger state through
solidification process. Essentially, the node requests all messages down to the genesis from the current tips of its neighbors.
Once the genesis is found, messages are solidified bottom up. For the value tangle, this means that for each solidified
and liked transaction, <code>TransactionConfirmed</code> event is triggered, updating the base mana vectors.</p>
<p>In case of a large database, initial synching and solidification is a computationally heavy task due to the sheer amount
of messages in the tangle. Mana calculation only adds to this burden. It will be determined through testing if additional
&quot;weight lifting&quot; mechanism is needed (for example delaying mana calculation).</p>
<p>In Pollen test network, all funds are initially held by the faucet node, therefore all mana present at bootstrap belong
to this node. Whenever a transaction is requested from the faucet, it pledges mana to the requesting node, helping other
nodes to increase their mana.</p>
<h3 id="mana-package"><a class="header" href="#mana-package">Mana Package</a></h3>
<p>The functionality of the mana module should be implemented in a <code>mana</code> package. Then, a <code>mana plugin</code> can use the package
structs and methods to connect the dots, for example execute <code>BookMana</code> when <code>TransactionConfirmed</code> event is triggered
in the value tangle.</p>
<p><code>BaseMana</code> is a struct that holds the different mana values for a given node.
Note that except for <code>Base Mana 1</code> calculation, we need the time when <code>BaseMana</code> values were updated, so we store it in the struct:</p>
<pre><code class="language-go">type BaseMana struct {
 BaseMana1 float
 EffectiveBaseMana1 float
 BaseMana2 float
 EffectiveBaseMana2 float
 LastUpdated time
}
</code></pre>
<p><code>BaseManaVector</code> is a data structure that maps <code>nodeID</code>s to <code>BaseMana</code>. It also has a <code>Type</code> that denotes the type
of mana this vector deals with (Access, Consensus, etc.).</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p><code>BaseManaVector</code> should have the following methods:</p>
<ul>
<li><code>BookMana(transaction)</code>: Book mana of a transaction. Trigger <code>ManaBooked</code> event. Note, that this method updates
<code>BaseMana</code> with respect to time and to new <code>Base Mana 1</code> and <code>Base Mana 2</code> values.</li>
<li><code>GetWeightedMana(nodeID, weight) mana</code>: Return <code>weight</code> *<code> Effective Base Mana 1</code> + (1-<code>weight</code>)+<code>Effective Base Mana 2</code>.
<code>weight</code> is a number in [0,1] interval. Notice, that <code>weight</code> = 1  results in only returning <code>Effective Base Mana 1</code>,
and the other way around. Note, that this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>GetMana(nodeID) mana</code>: Return 0.5*<code>Effective Base Mana 1</code> + 0.5*<code>Effective Base Mana 2</code> of a particular node. Note, that
this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>update(nodeID, time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of a node with respect <code>time</code>.</li>
<li><code>updateAll(time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of all nodes with respect to <code>time</code>.</li>
</ul>
<p><code>BaseMana</code> should have the following methods:</p>
<ul>
<li><code>pledgeAndUpdate(transaction)</code>: update <code>BaseMana</code> fields and pledge mana with respect to <code>transaction</code>.</li>
<li><code>revokeBaseMana1(amount, time)</code>:  update <code>BaseMana</code> values with respect to <code>time</code> and revoke <code>amount</code> <code>BaseMana1</code>.</li>
<li><code>update(time)</code>: update all <code>BaseMana</code> fields with respect to <code>time</code>.</li>
<li><code>updateEBM1(time)</code>: update <code>Effective Base Mana 1</code> wrt to <code>time</code>.</li>
<li><code>updateBM2(time)</code>: update <code>Base Mana 2</code> wrt to <code>time</code>.</li>
<li><code>updateEBM2(time)</code>: update <code>Effective Base Mana 2</code> wrt to <code>time</code>.</li>
</ul>
<h4 id="base-mana-calculation"><a class="header" href="#base-mana-calculation">Base Mana Calculation</a></h4>
<p>There are two cases when the values within <code>Base Mana Vector</code> are updated:</p>
<ol>
<li>A confirmed transaction pledges mana.</li>
<li>Any module accesses the <code>Base Mana Vector</code>, and hence its values are updated with respect to <code>access time</code>.</li>
</ol>
<p>First, let's explore the former.</p>
<h5 id="a-confirmed-transaction-pledges-mana"><a class="header" href="#a-confirmed-transaction-pledges-mana">A confirmed transaction pledges mana</a></h5>
<p>For simplicity, we only describe mana calculation for one of the Base Mana Vectors, namely, the Base Access Mana Vector.</p>
<p>First, a <code>TransactionConfirmed</code> event is triggered, therefore <code>BaseManaVector.BookMana(transaction)</code> is executed:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) BookMana(tx *transaction) {
    pledgedNodeID := tx.accessMana

    for input := range tx.inputs {
        // search for the nodeID that the input's tx pledged its mana to
        inputNodeID := loadPledgedNodeIDFromInput(input)
        // save it for proper event trigger
        oldMana := bmv[inputNodeID]
        // revoke BM1
        bmv[inputNodeID].revokeBaseMana1(input.balance, tx.timestamp)

        // trigger events
        Events.ManaRevoked.Trigger(&amp;ManaRevokedEvent{inputNodeID, input.balance, tx.timestamp, AccessManaType})
        Events.ManaUpdated.Tigger(&amp;ManaUpdatedEvent{inputNodeID, oldMana, bmv[inputNodeID], AccessManaType})
    }

    // save it for proper event trigger
    oldMana :=  bmv[pledgedNodeID]
    // actually pledge and update
    bm1Pledged, bm2Pledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)

    // trigger events
    Events.ManaPledged.Trigger(&amp;ManaPledgedEvent{pledgedNodeID, bm1Pledged, bm2Pledged, tx.timestamp, AccessManaType})
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{pledgedNodeID, oldMana, bmv[pledgedNodeID], AccessManaType})
}
</code></pre>
<p><code>Base Mana 1</code> is being revoked from the nodes that pledged mana for inputs that the current transaction consumes.
Then, the appropriate node is located in <code>Base Mana Vector</code>, and mana is pledged to its <code>BaseMana</code>.
<code>Events</code> are essential to study what happens within the module from the outside.</p>
<p>Note, that <code>revokeBaseMana1</code> accesses the mana entry of the nodes within <code>Base Mana Vector</code>, therefore all values are
updated with respect to <code>t</code>. Notice the two branches after the condition. When <code>Base Mana</code> values had been updated before
the transaction's timestamp, a regular update is carried out. However, if <code>t</code> is older, than the transaction timestamp,
an update in the &quot;past&quot; is carried out and values are updated up to <code>LastUpdated</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) revokeBaseMana1(amount float64, t time.Time) {
	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)

		bm.LastUpdated = t
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
	} else {
		// update in past
		n := bm.LastUpdated.Sub(t)
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
		// update EBM1 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
	}
}
</code></pre>
<p>The same regular and past update scheme is applied to pledging mana too:</p>
<pre><code class="language-go">func (bm *BaseMana) pledgeAndUpdate(tx *transaction) (bm1Pledged int, bm2Pledged int){
	t := tx.timestamp
	bm1Pledged = sum_balance(tx.inputs)

	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)
		bm.LastUpdated = t
		bm.BaseMana1 += bm1Pledged
		// pending mana awarded, need to see how long funds sat
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
	} else {
		// past update
		n := bm.LastUpdated.Sub(t)
		// update BM1 and BM2 at `t`
		bm.BaseMana1 += bm1Pledged
		oldMana2 = bm.BaseMana2
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
		// update EBM1 and EBM2 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
		if EMA_coeff_2 != decay {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-
                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)
		} else {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) * decay * n
		}
}
	return bm1Pledged, bm2Pledged
}
</code></pre>
<p>Notice, that in case of <code>EMA_coeff_2 = decay</code>, a simplified formula can be used to calculate <code>EffectiveBaseMana2</code>.
The same approach is applied in <code>updateEBM2()</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) updateEBM1(n time.Duration) {
    bm.EffectiveBaseMana1 = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectiveBaseMana1 +
                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BaseMana1
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateBM2(n time.Duration) {
    bm.BaseMana2 = bm.BaseMana2 * math.Pow(math.E, -decay*n)
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateEBM2(n time.Duration) {
	if EMA_coeff_2 != decay {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveBaseMana2 +
			(math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /
				(EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseMana2
	} else {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -decay * n)*bm.EffectiveBaseMana2 +
			decay * n * bm.BaseMana2
	}
}
</code></pre>
<h5 id="any-module-accesses-the-base-mana-vector"><a class="header" href="#any-module-accesses-the-base-mana-vector">Any module accesses the Base Mana Vector</a></h5>
<p>In this case, the accessed entries within <code>Base Mana Vector</code> are updated via the method:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) update(nodeID ID, t time.Time ) {
    oldMana :=  bmv[nodeID]
    bmv[nodeID].update(t)
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{nodeID, oldMana, bmv[nodeID], AccessManaType})
}
</code></pre>
<p>where <code>t</code> is the access time.</p>
<pre><code class="language-go">func (bm *BaseMana) update(t time.Time ) {
    n := t - bm.LastUpdated
    bm.updateEBM1(n)
    bm.updateBM2(n)
    bm.updateEBM2(n)

    bm.LastUpdated = t
}
</code></pre>
<h4 id="events"><a class="header" href="#events">Events</a></h4>
<p>The mana package should have the following events:</p>
<ul>
<li><code>Pledged</code> when mana (<code>BM1</code> and <code>BM2</code>) was pledged for a node due to new transactions being confirmed.</li>
</ul>
<pre><code class="language-go">type PledgedEvent struct {
    NodeID []bytes
    AmountBM1 int
    AmountBM2 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Revoked</code> when mana (<code>BM1</code>) was revoked from a node.</li>
</ul>
<pre><code class="language-go">type RevokedEvent struct {
    NodeID []bytes
    AmountBM1 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Updated</code> when mana was updated for a node due to it being accessed.</li>
</ul>
<pre><code class="language-go">type UpdatedEvent struct {
    NodeID []bytes
    OldMana BaseMana
    NewMana BaseMana
    Type    ManaType // access or consensus
}
</code></pre>
<h4 id="testing"><a class="header" href="#testing">Testing</a></h4>
<ul>
<li>Write unit tests for all methods.</li>
<li>Test all events and if they are correctly triggered.</li>
<li>Benchmark calculations in tests to see how heavy it is to calculate EMAs and decays.</li>
</ul>
<h3 id="mana-plugin"><a class="header" href="#mana-plugin">Mana Plugin</a></h3>
<p>The <code>mana plugin</code> is responsible for:</p>
<ul>
<li>calculating mana from value transactions,</li>
<li>keeping a log of the different mana values of all nodes,</li>
<li>updating mana values,</li>
<li>responding to mana related queries from other modules,</li>
<li>saving base mana vectors in database when shutting down the node,</li>
<li>trying to load base mana vectors from database when starting the node.</li>
</ul>
<p>The proposed mana plugin should keep track of the different mana values of nodes and handle calculation
updates. Mana values are mapped to <code>nodeID</code>s and stored in a <code>map</code> data structure. The vector also stores information on
what <code>Type</code> of mana it handles.</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<p><code>Access Mana</code> and <code>Consensus Mana</code> should have their own respective <code>BaseManaVector</code>.</p>
<pre><code class="language-go">accessManaVector := BaseManaVector{vectorType: AccesMana}
consensusManaVector :=  BaseManaVector{vectorType: ConsensusMana}
</code></pre>
<p>In the future, it should be possible to combine <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> from a <code>BaseManaVector</code>
in arbitrary proportions to arrive at a final mana value that other modules use. The <code>mana package</code> has these methods
in place. Additionally, a parameter could be passed to the <code>getMana</code> type of exposed functions to set the proportions.</p>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<p>The mana plugin should expose utility functions to other modules:</p>
<ul>
<li><code>GetHighestManaNodes(type, n) [n]NodeIdManaTuple</code>: return the <code>n</code> highest <code>type</code> mana nodes (<code>nodeID</code>,<code>manaValue</code>) in
ascending order. Should also update their mana value.</li>
<li><code>GetManaMap(type) map[nodeID]manaValue</code>: return <code>type</code> mana perception of the node.</li>
<li><code>GetAccessMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Access Mana</code>, update its values with respect to time,
and return the amount of <code>Access Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetConsensusMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Consensus Mana</code>, update its values with respect to time,
and returns the amount of <code>Consensus Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetNeighborsMana(type)</code>: returns the <code>type</code> mana of the nodes neighbors</li>
<li><code>GetAllManaVectors()</code> Obtaining the full mana maps for comparison with the perception of other nodes.</li>
<li><code>GetWeightedRandomNodes(n)</code>: returns a weighted random selection of <code>n</code> nodes. <code>Consensus Mana</code> is used for the weights.</li>
<li>Obtaining a list of currently known peers + their mana, sorted. Useful for knowing which high mana nodes are online.</li>
<li><code>OverrideMana(nodeID, baseManaVector)</code>: Sets the nodes mana to a specific value. Can be useful for debugging, setting faucet mana, initialization, etc.. Triggers <code>ManaUpdated</code></li>
</ul>
<p>Such utility functions could be used for example to visualize mana distribution in node dashboard, or send neighbor
mana data to the analysis server for further processing.</p>
<h4 id="booking-mana"><a class="header" href="#booking-mana">Booking Mana</a></h4>
<p>Mana is booked when a transaction is confirmed.</p>
<pre><code class="language-go">on TransactionConfirmed (tx):
 bookAccessMana()
 bookConsensusMana()
</code></pre>
<h4 id="synchronization-and-mana-calculation"><a class="header" href="#synchronization-and-mana-calculation">Synchronization and Mana Calculation</a></h4>
<p>The mana plugin is responsible to determine when to start calculating mana locally.
Since mana state is an extension to ledger state, it can only depict realistic mana values once the node is in sync.
During syncing, ledger state is constructed from messages coming from neighbors as described further above.</p>
<p>In this first iteration, mana plugin relies on <code>TransactionConfirmed</code> event of the value transfers plugin, and has no
explicit rules on when to start and stop mana calculation.</p>
<p>In future, initial mana state (together with the initial ledger state) will be derived from a snapshot file.</p>
<h3 id="mana-toolkit"><a class="header" href="#mana-toolkit">Mana Toolkit</a></h3>
<p>In this section, all tools and utility functions for mana will be outlined.</p>
<h4 id="mana-related-api-endpoints"><a class="header" href="#mana-related-api-endpoints">Mana Related API endpoints</a></h4>
<ul>
<li><code>/info</code>: Add own mana in node info response.</li>
<li><code>value/allowedManaPledge</code>: Endpoint that clients can query to determine which nodeIDs are allowed as part of
<code>accessMana</code> and <code>consensusMana</code> fields in a transaction.</li>
<li><code>value/sendTransactionByJson</code>: Add <code>accessMana</code>, <code>consensusMana</code> and <code>timestamp</code> fields to the JSON request.</li>
</ul>
<p>Add a new <code>mana</code> endpoint route:</p>
<ul>
<li><code>/mana</code>: Return access and consensus mana of the node.</li>
<li><code>/mana/all</code>: Return whole mana map (mana perception of the node).</li>
<li><code>/mana/access/nhighest</code>: Return <code>n</code> highest access mana holder <code>nodeIDs</code> and their access mana values.</li>
<li><code>/mana/consensus/nhighest</code>: Return <code>n</code> highest consensus mana holder <code>nodeIDs</code> and their consensus mana values.</li>
<li><code>/mana/percentile</code>: Return the top percentile the node belongs to relative to the network. For example, if there are 100 nodes in the
network owning mana, and a node is the 13th richest, it means that is part of the top 13% of mana holders, but not the
top 12%.</li>
</ul>
<h4 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics collection</a></h4>
<p>To study the mana module, following metrics could be gathered:</p>
<ul>
<li>Amount of consensus and access mana present in the network. (amount varies because of <code>Base Mana 2</code>).</li>
<li>Amount of mana each node holds.</li>
<li>Number of (and amount of mana) a node was pledged with mana in the last <code>t</code> interval.</li>
<li>Mana development of a particular node over time.</li>
<li>Mana percentile development of a node over time.</li>
<li>Average pledge amount of a node. (how much mana it receives on average with one pledge)</li>
<li>Mean and median mana holdings of nodes in the network. Shows how even mana distribution is.</li>
<li>Average mana of neighbors.</li>
</ul>
<h4 id="visualization"><a class="header" href="#visualization">Visualization</a></h4>
<p>Each node calculates mana locally, not only for themselves, but for all nodes in the network that it knows. As a result,
mana perception of nodes may not be exactly the same at all times (due to network delay, processing capabilities), but
should converge to the same state. A big question for visualization is which node's viewpoint to base mana visualization on? </p>
<p>When running a node, operators will be shown the mana perception of their own node, but it also makes sense to
display the perception of high mana nodes as the global mana perception. First, let's look at how local mana perception
is visualized for a node:</p>
<h5 id="local-perception"><a class="header" href="#local-perception">Local Perception</a></h5>
<p>There are two ways to visualize mana in GoShimmer:</p>
<ol>
<li>Node Local Dashboard</li>
<li>Grafana Dashboard</li>
</ol>
<p>While <code>Local Dashboard</code> gives flexibility in what and how to visualize, <code>Grafana Dashboard</code> is better at storing historic
data but can only visualize time series. Therefore, both of these ways will be utilized, depending on which suits the best.</p>
<p><code>Local Dashboard</code> visualization:</p>
<ul>
<li>Histogram of mana distribution within the network.</li>
<li>List of <code>n</code> richest mana nodes, ordered.</li>
<li>Mana rank of node.</li>
</ul>
<p><code>Grafana Dashboard</code> visualization:</p>
<ul>
<li>Mana of a particular node with respect to time.</li>
<li>Amount of mana in the network.</li>
<li>Average pledge amount of a node.</li>
<li>Mean and median mana holdings of nodes.</li>
<li>Mana rank of the node over time.</li>
<li>Average mana of neighbors.</li>
</ul>
<h5 id="global-perception"><a class="header" href="#global-perception">Global Perception</a></h5>
<p>Additionally, the Pollen Analyzer (analysis server) could be updated:</p>
<ul>
<li>Autopeering node graph, where size of a node corresponds to its mana value.</li>
<li>Some previously described metrics could be visualized here as well, to give the chance to people without
a node to take a look. As an input, a high mana node's perception should be used.</li>
</ul>
<h1 id="markers"><a class="header" href="#markers">Markers</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In order to know whether a message in the Tangle is orphaned or not, we introduce <strong>grades of finality</strong> to interpret the status of a message. The higher grade of finality is determined by the <strong>approval weight</strong>, which is the proportion of active consensus mana approving a given message.</p>
<p>In order to compute the approval weight of a given message  we need to traverse the Tangle from the message to the tips and sum up the active consensus mana of all the messages in its future cone. A <strong>marker</strong> is a tool to efficiently estimate the approval weight of a message and that reduces the portion of the Tangle we need to walk, and which finally results in the grade of finality.</p>
<p><strong>Note</strong>: <em>Markers</em> is not a core module of the Coordicide project.</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p><em>Markers</em> is a tool to infer knowledge about the structure of the Tangle in terms of:
+ past/future cone membership;
+ approximate approval weight of any message;
+ tagging sections of the Tangle (e.g., branches) without having to traverse each message individually.</p>
<h2 id="dependency"><a class="header" href="#dependency">Dependency</a></h2>
<p>Active Consensus Mana</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<p>Let's define the terms related to markers:</p>
<ul>
<li><strong>Sequence:</strong> A Sequence is a sequence of markers. Each Sequence corresponds to a UTXO branch, which help us to track the structure independently. </li>
<li><strong>Sequence Identifier (<code>SID</code>):</strong> A Sequence Identifier is the unique identifier of a Sequence.</li>
<li><strong>Marker Index (<code>MI</code>):</strong> A Marker Index is the marker rank in the marker DAG. Throughout the code the marker rank will be called index. </li>
<li><strong>marker:</strong> A marker is a pair of numbers: <code>SID</code> and <code>MI</code> associated to a given message. Markers carrying the same <code>SID</code> belong to the same Sequence.</li>
<li><strong>future marker (<code>FM</code>):</strong> A future marker of a message is the first marker in its future cone from different sequences; this field in the message metadata is updated when the new marker is generated in the future, following the rules defined in <a href="specification/003-markers.html#future-markers">Future Markers</a>.</li>
<li><strong>past marker (<code>PM</code>):</strong> A past marker of a message is a marker in its past cone. For a given sequence it is set to the newest past marker of its parents, that is the one that has the largest <code>MI</code>. The past marker of a marker is set to itself.</li>
<li><strong>sequence rank:</strong> The rank of a sequence will be simply called rank throughout this code. Bear in mind that for clarity the marker rank is called index.</li>
</ul>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<h3 id="the-markers"><a class="header" href="#the-markers">The Markers</a></h3>
<p>Markers are messages selected from the tip set periodically and assigned unique identifiers, in the form of $[SID, MI]$. </p>
<h4 id="marker-structure"><a class="header" href="#marker-structure">Marker Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>SequenceID</td>
        <td>uint64</td>
        <td>The Sequence identifier of the marker.</td>
    </tr>
    <tr>
        <td>Index</td>
        <td>uint64</td>
        <td>The index of the marker in the sequence.</td>
    </tr>
</table>
<h4 id="create-markers"><a class="header" href="#create-markers">Create Markers</a></h4>
<p>A new marker is created when:</p>
<ol>
<li>the default conditions are met, which will be one of these options:
<ul>
<li><strong>every x messsages</strong>;</li>
</ul>
<ul>
<li><strong>every t seconds</strong>;</li>
<li>a mix of the first two!
<ul>
<li>Upperbound given by the messages</li>
<li>Lower temporal bound given by the time</li>
</ul>
</li>
<li>every x messages that reference (directly or indirectly) the previous marker
<ul>
<li>Lower bound given by rank (e.g., how far you are in terms of steps) -&gt; &gt;= 10 or something</li>
<li>Upper bound given by the amount of messages referencing the previous one -&gt; ~ 200 msgs</li>
</ul>
</li>
</ul>
</li>
<li>A new sequence is created. </li>
</ol>
<blockquote>
<p>:mega: to be confirmed here.</p>
</blockquote>
<p>A new marker is selected from the strong tips set randomly, and selected from the weak tips set if there's no strong tip. A new pair of $[SID, MI]$ is assigned to the new marker. </p>
<blockquote>
<p>:mega:  to be confirmed here.</p>
</blockquote>
<p>The <code>SID</code> is set according to the following rules:</p>
<ul>
<li>Inherit the <code>SID</code> from parents if the new marker references the latest marker of a sequence and meets the requirement to set up a new marker without initiating a new MS.</li>
<li>Create a new <code>SID</code> if it is the first marker of a new sequence.</li>
</ul>
<p>The <code>MI</code> is set to $MI = 1+ max(referencedMI)$, which complies to the rule:</p>
<ul>
<li>Marker indexes (<code>MI</code>s) are monotonically increasing such that $\forall x \in fc(y)$ =&gt; $MI_x &gt; MI_y$, where $fc(y)$ is the future cone of $y$ and $x$ is any message in that future cone.</li>
</ul>
<h3 id="markers-in-messages"><a class="header" href="#markers-in-messages">Markers in Messages</a></h3>
<p>Each message keeps its associated marker information in two lists:</p>
<ul>
<li>past markers </li>
<li>future markers </li>
</ul>
<p>These lists for past markers and future markers are used to determine whether a message is in the past cone of the other, and the list for future markers also helps us to efficiently estimate the approval weight of a message.</p>
<h4 id="structuredetails-structure"><a class="header" href="#structuredetails-structure">StructureDetails Structure</a></h4>
<p>StructureDetails is a structure that will be in the message metadata containing marker information.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Rank</td>
        <td>uint64</td>
        <td>The rank of the message.</td>
    </tr>
    <tr>
        <td>IsPastMarker</td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td>PastMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>PM list</b>, a list of PMs from different sequences.</td>
    </tr>
    <tr>
        <td>FutureMarkers</td>
        <td>map[SequenceID]Index</td>
        <td><b>FM list</b>, a list of FMs from different sequences.</td>     
    </tr>
</table>
<h5 id="past-markers"><a class="header" href="#past-markers">Past Markers</a></h5>
<ul>
<li>The <code>PM</code> list of a marker contains the marker itself only.</li>
<li>The <code>PM</code> list of non-marker messages is inherited from its <strong>strong</strong> parents, with 2 steps:
<ol>
<li>for a given sequence select only the nearest marker (i.e. the markers with the highest <code>MI</code>). Thus for every sequence from the parents there will be exactly one marker.</li>
<li>remove those that have been referenced by other markers from this set. </li>
</ol>
</li>
</ul>
<h5 id="future-markers"><a class="header" href="#future-markers">Future Markers</a></h5>
<p>The <code>FM</code> list of a message is empty at start and gets updated when a new marker directly or indirectly references it. The propagation of a <code>FM</code> to its past cone (i.e. the update of the <code>FutureMarkers</code> field in the encountered messages) does not continue beyond a message if:</p>
<ol>
<li>the <code>FM</code> list of a message includes a previous marker of the same sequence;</li>
<li>the message is the marker in the different sequence, we update the <code>FM</code> list of that marker only.</li>
</ol>
<h3 id="the-sequence"><a class="header" href="#the-sequence">The Sequence</a></h3>
<p>Sequences are used to track the UTXO DAG branches, each branch corresponds to a sequence with a unique <code>SID</code>, and the sequences form a DAG as well.</p>
<h4 id="sequence-structure"><a class="header" href="#sequence-structure">Sequence Structure</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>id</td>
        <td>uint64</td>
        <td>The sequence identifier of the sequence.</td>
    </tr>
    <tr>
        <td>parentReferences</td>
        <td>map[uint64]Thresholdmap</td>
        <td>The marker referenced map of each parent marker.</td>
    </tr>
    <tr>
        <td>rank</td>
        <td>uint64</td>
        <td>The rank of the sequence in the marker DAG.</td>
    </tr>
    <tr>
        <td>highestIndex</td>
        <td>uint64</td>
        <td>The highest MI of the marker sequence.</td>
    </tr>
    <tr>
        <td>lowestIndex</td>
        <td>uint64</td>
        <td>The lowest MI of the sequence.</td>
    </tr>
</table>
<h4 id="create-sequence"><a class="header" href="#create-sequence">Create Sequence</a></h4>
<p>A new sequence is created when:</p>
<ol>
<li>there's a conflict in a UTXO branch.</li>
<li>the UTXO branches are aggregated.</li>
<li>UTXO branches are merged.</li>
</ol>
<p>Each new sequence starts from a new marker.</p>
<h4 id="sequences"><a class="header" href="#sequences">Sequences</a></h4>
<p>For whatever reason a sequence is created, we assign a new $SID = 1+max(referenceSequencesIdentifiers)$. To prevent assigning a new <code>SID</code> when combining same sequences again, we build parents-child relation in a map if a new sequence is created. </p>
<h4 id="sequence-rank"><a class="header" href="#sequence-rank">Sequence Rank</a></h4>
<p>The rank of a sequence graph is the number of sequences from the starting point to itself. The sequence ranks are shown in the figure above.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example 1</a></h2>
<p>Here is an example of how the markers and sequences structures would look in the Tangle:
The purple colored messages are markers.</p>
<p><img src="https://i.imgur.com/GENej3O.png" alt="" /></p>
<h2 id="example-2-test-for-the-mapping-interaction-with-the-booker"><a class="header" href="#example-2-test-for-the-mapping-interaction-with-the-booker">Example 2: Test for the Mapping interaction with the Booker</a></h2>
<p>The Marker tool implementation is tested for correct Marker and Booker mapping. A transaction-by-transaction discussion of the test can be found <a href="specification/./../../packages/tangle/images/TestBookerMarkerMappings.html">here</a> and can be viewed by opening the file locally in a browser. Transactions arrive in the order of the their transaction number. The end result and the values in the various fields is shown in the following figures:</p>
<p><img src="https://imgur.com/h6Hs3xG.png" alt="" /></p>
<p><img src="https://imgur.com/sCkXXrG.png" alt="" /></p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>In the following we describe some of the functions in more detail.</p>
<h3 id="normalization-of-the-referenced-pms-and-sequences"><a class="header" href="#normalization-of-the-referenced-pms-and-sequences">Normalization of the referenced PMs and Sequences</a></h3>
<p>Messages can have markers from different sequences in <code>PM</code> list and <code>FM</code> list, the order and referenced relationship among sequences are important for example when it comes to inheriting the <code>PM</code> list from parents. Thus, we need to track these sequences.</p>
<p>When a new sequence is created we check the parent marker' sequences with the function <code>normalizeMarkers()</code> in order from high to low rank. In this function, we remove those <code>PM</code>s that it's belonging sequence is referenced by others.</p>
<p>An example is <strong>msg 10</strong> in the figure above, $[0,2], [1,1], [2,3]$ are <code>PM</code>s to be considered to inherit. $[2,3]$ is the first marker to check, since it has the highest sequence rank. We select the parent sequences of $[2,3]$, which are $0$ and $1$, and the referenced <code>PM</code>s therein. Next any <code>PM</code>s that are already referenced can be removed. This results in that the PMs of <strong>msg 10</strong> is $[2,3]$ only.</p>
<p>In the following we show the implementation of  <code>normalizeMarkers()</code>, which returns the markers and sequences that will be inherited from a message.</p>
<pre><code class="language-go">// normalizeMarkers takes a set of Markers and removes each Marker that is already referenced by another Marker in the
// same set (the remaining Markers are the &quot;most special&quot; Markers that reference all Markers in the set grouped by the
// rank of their corresponding Sequence). In addition, the method returns all SequenceIDs of the Markers that were not
// referenced by any of the Markers (the tips of the Sequence DAG).
func (m *Manager) normalizeMarkers(markers *Markers) (normalizedMarkersByRank *markersByRank, normalizedSequences SequenceIDs) {
	rankOfSequencesCache := make(map[SequenceID]uint64)

	normalizedMarkersByRank = newMarkersByRank()
	normalizedSequences = make(SequenceIDs)
	// group markers with same sequence rank
	markers.ForEach(func(sequenceID SequenceID, index Index) bool {
		normalizedSequences[sequenceID] = types.Void
		normalizedMarkersByRank.Add(m.rankOfSequence(sequenceID, rankOfSequencesCache), sequenceID, index)

		return true
	})
	markersToIterate := normalizedMarkersByRank.Clone()

	//iterate from highest sequence rank to lowest
	for i := markersToIterate.HighestRank() + 1; i &gt; normalizedMarkersByRank.LowestRank(); i-- {
		currentRank := i - 1
		markersByRank, rankExists := markersToIterate.Markers(currentRank)
		if !rankExists {
			continue
		}

		// for each marker from the current sequence rank check if we can remove a marker in normalizedMarkersByRank,
		// and add the parent markers to markersToIterate if necessary
		if !markersByRank.ForEach(func(sequenceID SequenceID, index Index) bool {
			if currentRank &lt;= normalizedMarkersByRank.LowestRank() {
				return false
			}

			if !(&amp;CachedSequence{CachedObject: m.sequenceStore.Load(sequenceID.Bytes())}).Consume(func(sequence *Sequence) {
				// for each of the parentMarkers of this particular index
				sequence.HighestReferencedParentMarkers(index).ForEach(func(referencedSequenceID SequenceID, referencedIndex Index) bool {
					// of this marker delete the referenced sequences since they are no sequence tips anymore in the sequence DAG
					delete(normalizedSequences, referencedSequenceID)

					rankOfReferencedSequence := m.rankOfSequence(referencedSequenceID, rankOfSequencesCache)
					// check whether there is a marker in normalizedMarkersByRank that is from the same sequence
					if index, indexExists := normalizedMarkersByRank.Index(rankOfReferencedSequence, referencedSequenceID); indexExists {
						if referencedIndex &gt;= index {
							// this referencedParentMarker is from the same sequence as a marker in the list but with higher index - hence remove the index from the Marker list
							normalizedMarkersByRank.Delete(rankOfReferencedSequence, referencedSequenceID)

							// if rankOfReferencedSequence is already the lowest rank of the original markers list,
							// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
							if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
								markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
							}
						}

						return true
					}

					// if rankOfReferencedSequence is already the lowest rank of the original markers list,
					// no need to add it since parents of the referencedMarker cannot delete any further elements from the list
					if rankOfReferencedSequence &gt; normalizedMarkersByRank.LowestRank() {
						markersToIterate.Add(rankOfReferencedSequence, referencedSequenceID, referencedIndex)
					}

					return true
				})
			}) {
				panic(fmt.Sprintf(&quot;failed to load Sequence with %s&quot;, sequenceID))
			}

			return true
		}) {
			return
		}
	}

	return
}
</code></pre>
<h3 id="markers-application-past-cone-check"><a class="header" href="#markers-application-past-cone-check">Markers Application: Past Cone Check</a></h3>
<p>By comparing the past and future markers of messages, we can easily tell if one is in another's past cone. The function returns a <code>TriBool</code> representing the three possible statuses: <code>True</code>, <code>False</code> and <code>Maybe</code>. If <code>Maybe</code> is returned, then we need to perform a search of the Tangle by walking by means of e.g. a Breadth-First Search.</p>
<p>In the following we show the implementation of the past cone check: </p>
<pre><code class="language-go">// IsInPastCone checks if the earlier Markers are directly or indirectly referenced by the later Markers.
func (m *Manager) IsInPastCone(earlierMarkers *MarkersPair, laterMarkers *MarkersPair) (referenced TriBool) {
	// fast check: if earlier Markers have larger highest Indexes they can't be in the past cone
	if earlierMarkers.PastMarkers.HighestIndex() &gt; laterMarkers.PastMarkers.HighestIndex() {
		return False
	}

	// fast check: if earlier Marker is a past Marker and the later ones reference it we can return early
	if earlierMarkers.IsPastMarker {
		earlierMarker := earlierMarkers.PastMarkers.FirstMarker()
		if earlierMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		if laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(earlierMarker.sequenceID); sequenceExists {
			if laterIndex &gt;= earlierMarker.index {
				return True
			}

			return False
		}

		if laterMarkers.PastMarkers.HighestIndex() &lt;= earlierMarker.index {
			return False
		}
	}

	if laterMarkers.IsPastMarker {
		laterMarker := laterMarkers.PastMarkers.FirstMarker()
		if laterMarker == nil {
			panic(&quot;failed to retrieve Marker&quot;)
		}

		// if the earlier Marker inherited an Index of the same Sequence that is higher than the later we return false
		if earlierIndex, sequenceExists := earlierMarkers.PastMarkers.Get(laterMarker.sequenceID); sequenceExists &amp;&amp; earlierIndex &gt;= laterMarker.index {
			return False
		}

		// if the earlier Markers are referenced by a Marker of the same Sequence that is larger, we are not in the past cone
		if earlierFutureIndex, earlierFutureIndexExists := earlierMarkers.FutureMarkers.Get(laterMarker.sequenceID); earlierFutureIndexExists &amp;&amp; earlierFutureIndex &gt; laterMarker.index {
			return False
		}

		// if the earlier Markers were referenced by the same or a higher future Marker we are not in the past cone
		// (otherwise we would be the future marker)
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			earlierIndex, similarSequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
			return !similarSequenceExists || earlierIndex &lt; laterIndex
		}) {
			return False
		}

		if earlierMarkers.PastMarkers.HighestIndex() &gt;= laterMarker.index {
			return False
		}
	}

	// if the highest Indexes of both past Markers are the same ...
	if earlierMarkers.PastMarkers.HighestIndex() == laterMarkers.PastMarkers.HighestIndex() {
		// ... then the later Markers should contain exact copies of all of the highest earlier Markers because parent
		// Markers get inherited and if they would have been captured by a new Marker in between then the highest
		// Indexes would no longer be the same
		if !earlierMarkers.PastMarkers.ForEach(func(sequenceID SequenceID, earlierIndex Index) bool {
			if earlierIndex == earlierMarkers.PastMarkers.HighestIndex() {
				laterIndex, sequenceExists := laterMarkers.PastMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; laterIndex != earlierIndex
			}

			return true
		}) {
			return False
		}
	}

	if earlierMarkers.FutureMarkers.HighestIndex() == laterMarkers.FutureMarkers.HighestIndex() &amp;&amp; false {
		// the earlier future markers need to contain all later ones because if there would be another marker in between that shadows them the later future Marker would have a higher index
		if !laterMarkers.FutureMarkers.ForEach(func(sequenceID SequenceID, laterIndex Index) bool {
			if laterIndex == laterMarkers.FutureMarkers.highestIndex {
				earlierIndex, sequenceExists := earlierMarkers.FutureMarkers.Get(sequenceID)
				return sequenceExists &amp;&amp; earlierIndex == laterIndex
			}

			return true
		}) {
			return False
		}
	}

	// detailed check: earlier marker is referenced by something that the later one references
	if m.markersReferenceMarkers(laterMarkers.PastMarkers, earlierMarkers.FutureMarkers, false) {
		return True
	}

	// detailed check: the
	if m.markersReferenceMarkers(earlierMarkers.FutureMarkers, laterMarkers.PastMarkers, true) {
		return Maybe
	}

	return False
}

</code></pre>
<h3 id="markers-application-approval-weight-estimation"><a class="header" href="#markers-application-approval-weight-estimation">Markers Application: Approval Weight Estimation</a></h3>
<p>To approximate the approval weight of a message, we simply retrieve the approval weight of its <code>FM</code> list. Since the message is in the past cone of its <code>FM</code>s, the approval weight and the finality will be at least the same as its <code>FM</code>s. This will of course be a lower bound (which is the “safe” bound), but if the markers are set frequently enough, it should be a good approximation.</p>
<p>Details of managing approval weight of each marker and approval weight calculation of each messages refer to the Approval Weight Spec.
&gt;:mega: Add link here. </p>
<h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h1 id="glossary-1"><a class="header" href="#glossary-1">Glossary</a></h1>
<hr />
<h2 id="consensus"><a class="header" href="#consensus">CONSENSUS</a></h2>
<p>Agreement on a specific datum or value in distributed multi-agent systems, in the presence of faulty processes.</p>
<h3 id="blockchain-bottleneck"><a class="header" href="#blockchain-bottleneck">BLOCKCHAIN BOTTLENECK</a></h3>
<p>As more transactions are issued, the block rate and size become a bottleneck in the system. It can no longer include all incoming transactions promptly. Attempts to speed up block rates will introduce more orphan blocks (blocks being left behind) and reduce the security of the blockchain.</p>
<h3 id="nakamoto-consensus"><a class="header" href="#nakamoto-consensus">NAKAMOTO CONSENSUS</a></h3>
<p>Named after the originator of Bitcoin, Satoshi Nakamoto, Nakamoto consensus describes the replacement of voting/communication between known agents with a cryptographic puzzle (Proof-of-Work). Completing the puzzle determines which agent is the next to act.</p>
<h3 id="mining-races"><a class="header" href="#mining-races">MINING RACES</a></h3>
<p>In PoW-based DLTs, competition between nodes to obtain mining rewards and transaction fees are known as mining races. These are undesirable as they favor more powerful nodes, especially those with highly optimized hardware like ASICs. As such, they block participation by regular or IoT hardware and are harmful for the environment.</p>
<h3 id="proof-of-work"><a class="header" href="#proof-of-work">PROOF-OF-WORK</a></h3>
<p>Data which is difficult (costly, time-consuming) to produce but easy for others to verify.</p>
<hr />
<h2 id="coordinator"><a class="header" href="#coordinator">COORDINATOR</a></h2>
<p>A trusted entity that issues milestones to guarantee finality and protect the Tangle against attacks.</p>
<h3 id="milestones"><a class="header" href="#milestones">MILESTONES</a></h3>
<p>Milestones are transactions signed and issued by the Coordinator. Their main goal is to help the Tangle to grow healthily and to guarantee finality. When milestones directly or indirectly approve a transaction in the Tangle, nodes mark the state of that transaction and its entire history as confirmed.</p>
<hr />
<h2 id="tangle"><a class="header" href="#tangle">TANGLE</a></h2>
<p>An append only message data structure where each message references (at least) two other messages.</p>
<h3 id="subtangle"><a class="header" href="#subtangle">SUBTANGLE</a></h3>
<p>A consistent section of the Tangle (i.e. a subset of messages), such that each included message also includes its referenced messages.</p>
<hr />
<h2 id="network-layer"><a class="header" href="#network-layer">NETWORK LAYER</a></h2>
<p>This layer manages the lower layers of internet communication like TCP. It is the most technical, and in some ways the least interesting. In this layer, the connections between nodes are managed by the autopeering and peer discovery modules and the gossip protocol.</p>
<h3 id="peering"><a class="header" href="#peering">PEERING</a></h3>
<p>The procedure of discovering and connecting to other network nodes.</p>
<h3 id="neighbors"><a class="header" href="#neighbors">NEIGHBORS</a></h3>
<p>Network nodes that are directly connected and can exchange messages without intermediate nodes.</p>
<h3 id="node"><a class="header" href="#node">NODE</a></h3>
<p>A machine which is part of the IOTA network. Its role is to issue new transactions and to validate existing ones.</p>
<h3 id="small-world-network"><a class="header" href="#small-world-network">SMALL-WORLD NETWORK</a></h3>
<p>A network in which most nodes can be reached from every other node by a few intermediate steps.</p>
<h3 id="eclipse-attack"><a class="header" href="#eclipse-attack">ECLIPSE ATTACK</a></h3>
<p>A cyber-attack that aims to isolate and attack a specific user, rather than the whole network.</p>
<h3 id="splitting-attacks"><a class="header" href="#splitting-attacks">SPLITTING ATTACKS</a></h3>
<p>An attack in which a malicious node attempts to split the Tangle into two branches. As one of the branches grows, the attacker publishes transactions on the other branch to keep both alive. Splitting attacks attempt to slow down the consensus process or conduct a double spend.</p>
<h3 id="sybil-attack"><a class="header" href="#sybil-attack">SYBIL ATTACK</a></h3>
<p>An attempt to gain control over a peer-to-peer network by forging multiple fake identities.</p>
<hr />
<h2 id="communication-layer"><a class="header" href="#communication-layer">COMMUNICATION LAYER</a></h2>
<p>This layer stores and communicates information. This layer contains the “distributed ledger” or the tangle. The rate control and timestamps are in this layer too.</p>
<h3 id="message"><a class="header" href="#message">MESSAGE</a></h3>
<p>The object that is gossiped between neighbors. All gossiped information is included in a message. The most basic unit of information of the IOTA Protocol. Each message has a type and size and contains data.</p>
<h3 id="message-overhead"><a class="header" href="#message-overhead">MESSAGE OVERHEAD</a></h3>
<p>The additional information (metadata) that needs to be sent along with the actual information (data). This can contain signatures, voting, heartbeat signals, and anything that is transmitted over the network but is not the transaction itself.</p>
<h3 id="parent"><a class="header" href="#parent">PARENT</a></h3>
<p>A message approved by another message is called a parent to the latter. A parent can be selected as strong or weak parent. If the past cone of the parent is liked the parent is set as strong parent. If the message is liked but its past cone is disliked it is set as a weak parent. This mechanism is called approval switch.</p>
<h3 id="payload"><a class="header" href="#payload">PAYLOAD</a></h3>
<p>A field in a message which determines the type. Examples are:</p>
<ul>
<li>Value payload (type TransactionType)</li>
<li>FPC Opinion payload (type StatementType)</li>
<li>dRNG payload</li>
<li>Salt declaration payload</li>
<li>Generic data payload</li>
</ul>
<hr />
<h3 id="mana-1"><a class="header" href="#mana-1">MANA</a></h3>
<p>The reputation of a node is based on a virtual token called mana. This reputation, working as a Sybil protection mechanism, is important for issuing more transactions (see Module 3) and having a higher influence during the voting process (see Module 5).</p>
<h4 id="epoch"><a class="header" href="#epoch">EPOCH</a></h4>
<p>A time interval that is used for a certain type of consensus mana. At the end of each epoch a snapshot of the state of mana distribution in the network is taken. Since this tool employs the timestamp of messages every node can reach consensus on a epoch's mana distibution eventually.</p>
<hr />
<h3 id="transaction-1"><a class="header" href="#transaction-1">TRANSACTION</a></h3>
<p>A message with payload of type TransactionType. It contains the information of a transfer of funds.</p>
<h4 id="utxo"><a class="header" href="#utxo">UTXO</a></h4>
<p>Unspent transaction output.</p>
<h4 id="orphan"><a class="header" href="#orphan">ORPHAN</a></h4>
<p>A transaction (or block) that is not referenced by any succeeding transaction (or block). An orphan is not considered confirmed and will not be part of the consensus.</p>
<h4 id="reattachment"><a class="header" href="#reattachment">REATTACHMENT</a></h4>
<p>Resending a transaction by redoing tip selection and referencing newer tips by redoing PoW.</p>
<h4 id="history"><a class="header" href="#history">HISTORY</a></h4>
<p>The list of transactions directly or indirectly approved by a given transaction.</p>
<h4 id="solidification-time"><a class="header" href="#solidification-time">SOLIDIFICATION TIME</a></h4>
<p>The solidification time is the point at which the entire history of a transaction has been received by a node.</p>
<h4 id="finality"><a class="header" href="#finality">FINALITY</a></h4>
<p>The property that once a transaction is completed there is no way to revert or alter it. This is the moment when the parties involved in a transfer can consider the deal done. Finality can be deterministic or probabilistic.</p>
<hr />
<h3 id="tip-selection"><a class="header" href="#tip-selection">TIP SELECTION</a></h3>
<p>The process of selecting previous messages to be referenced by a new message. These references are where a message attaches to the existing data structure. IOTA only enforces that a message approves (at least) two other messages, but the tip selection strategy is left up to the user (with a good default provided by IOTA).</p>
<h4 id="tip"><a class="header" href="#tip">TIP</a></h4>
<p>A message that has not yet been approved.</p>
<h4 id="local-modifiers"><a class="header" href="#local-modifiers">LOCAL MODIFIERS</a></h4>
<p>Custom conditions that nodes can take into account during tip selection. In IOTA, nodes do not necessarily have the same view of the Tangle; various kinds of information only locally available to them can be used to strengthen security.</p>
<h4 id="approval-switch"><a class="header" href="#approval-switch">APPROVAL SWITCH</a></h4>
<p>When selecting a message as a parent, we can select from the strong or weak tip pool. This mechanism is called approval switch.</p>
<h4 id="approval-weight"><a class="header" href="#approval-weight">APPROVAL WEIGHT</a></h4>
<p>A message gains mana weight, by messages approving it directly or indirectly. However, only strong parents can propagate the mana weight to the past, while weak parents obtain the weight from its weak children but don't propagate it.</p>
<hr />
<h2 id="application-layer"><a class="header" href="#application-layer">APPLICATION LAYER</a></h2>
<p>The IOTA Protocol allows for a host of applications to run on the message tangle. Anybody can design an application, and users can decide which applications to run on their nodes. These applications will all use the communication layer to broadcast and store data.</p>
<h3 id="core-applications"><a class="header" href="#core-applications">CORE APPLICATIONS</a></h3>
<p>Applications that are necessary for the protocol to operate. These include for example:</p>
<ul>
<li>The value transfer application</li>
<li>The distributed random number generator (DRNG for short)</li>
<li>The Fast Probabilistic Consensus (FPC) protocol</li>
</ul>
<h3 id="value-transfer-application"><a class="header" href="#value-transfer-application">VALUE TRANSFER APPLICATION</a></h3>
<p>The application which maintains the ledger state.</p>
<h3 id="faucet"><a class="header" href="#faucet">FAUCET</a></h3>
<p>A test application issuing funds on request.</p>
<hr />
<h2 id="markers-1"><a class="header" href="#markers-1">MARKERS</a></h2>
<p>A tool that exists only locally and allows performing certain calculations more efficiently. Such as approval weight calculation or the existence of certain messages in the past or future cone of another message.</p>
<h1 id="layers"><a class="header" href="#layers">Layers</a></h1>
<blockquote>
<p>DISCLAIMER: The described layers describe how things are implemented in GoShimmer. They might not reflect final Coordicide specification or implementations.</p>
</blockquote>
<p>GoShimmer abstracts node functionalities into different layers. Similar to other architectures, upper layers build on the provided functionality of the layers below them. A layer is merely the concept of creating a clear separation of concerns.</p>
<p>Layers operate on payloads, and it is up to the layer to react to the wanted payload types.</p>
<h2 id="communication-layer-1"><a class="header" href="#communication-layer-1">Communication Layer</a></h2>
<p>The communication layer is the most primitive layer, as its job is to simply form a graph made out of messages which contain payloads. As the name implies, messages are communicated/gossiped throughout the entire network. Think of it as the &quot;physical layer&quot; in the OSI-model. This layer forms a DAG made up of messages as each message references two previous messages.</p>
<h3 id="message-1"><a class="header" href="#message-1">Message</a></h3>
<p>A message is a core data type which reflects a vertex in the communication layer <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>.</p>
<p>It contains following properties:</p>
<ul>
<li>References to other messages</li>
<li>Issuer's public key</li>
<li>The issuance time of the message</li>
<li>The message sequence number from the node which issued the message</li>
<li>Payload which might be interpreted by upper layers</li>
<li>The nonce which lets the message fulfill the PoW requirement</li>
<li>A Signature signing all the above fields.</li>
</ul>
<p>A message is gossiped only when it becomes solid, meaning that its past history is known to the node. Messages currently must become solid within a 30 seconds time period, otherwise they are discarded.</p>
<p>Messages must also fulfill a PoW requirement currently which involves finding a nonce so that the hash of the fields of the message (minus the signature) has a certain amount of leading zeros. The PoW currently operates on <code>BLAKE2b_512</code>. Later the PoW requirement will be substituted by the actual Coordicide rate control mechanisms.</p>
<p>A message's byte layout is defined as:</p>
<pre><code>parent_0&lt;64bytes&gt;
parent_1&lt;64bytes&gt;
issuer_public_key&lt;32bytes&gt;
issuance_time&lt;int64,8bytes&gt;
sequence_number&lt;uint64,8bytes&gt;
payload&lt;variable-size, max 64KBs&gt;
nonce&lt;uint64,8bytes&gt;
signature&lt;64bytes&gt;
</code></pre>
<h3 id="payloads"><a class="header" href="#payloads">Payloads</a></h3>
<p>As described above, a message contains a payload. In GoShimmer, there are 3 defined payload types, however, <a href="concepts/../tutorials/dApp.html">more such types can be defined by developers seeking to implement their own application on top of the communication layer</a>.</p>
<table><thead><tr><th>Type ID</th><th>Name</th><th>Purpose</th></tr></thead><tbody>
<tr><td>0</td><td>Data</td><td>Holds raw bytes without any further meaning</td></tr>
<tr><td>1</td><td>Value Object</td><td>Represents a value object on the value layer</td></tr>
<tr><td>111</td><td>DRNG Object</td><td>Represents a DRNG object for the DRNG layer</td></tr>
</tbody></table>
<p>A payload's byte layout is defined as:</p>
<pre><code>type&lt;uint32-4bytes&gt;
length&lt;uint32-4bytes&gt;
data&lt;length bytes&gt;
</code></pre>
<p>It is a upper layer's concern to listen for messages which hold specific payload types up on which the layer operates on.</p>
<h3 id="tip-selection-1"><a class="header" href="#tip-selection-1">Tip-Selection</a></h3>
<p>Since on the communication layer the payloads do not impose any restriction on the validity of a message, the tip-selection can simply operate on a pool of recent solid tips. However, in the future the tip-selector might impose certain restrictions such as below-max-depth checks and so on.</p>
<h2 id="value-layer"><a class="header" href="#value-layer">Value Layer</a></h2>
<p>The value layer operates solely on payloads of type value object. This layer has multiple responsibilities:</p>
<ul>
<li>Forming the ledger state</li>
<li>Processing, validating and issuing transactions</li>
<li>Conflict detection</li>
<li>Conflict resolution via FPC</li>
<li>Forming a DAG made up from value objects</li>
<li>Tip-selection (on value object tips)</li>
</ul>
<h3 id="value-object"><a class="header" href="#value-object">Value Object</a></h3>
<p>A value object is an object derived from a message containing a value object payload. It references two other value objects and contains one transaction.</p>
<p>The two references express vouching for the referenced value objects, meaning that they are seen as valid from the PoV of the value object which references them.</p>
<p>A value object is solid when its past cone is known, and the contained transaction's inputs are known.</p>
<p>A transaction can occur in multiple value objects. In that case we speak of reattachments.</p>
<p>A value object's byte layout is defined as:</p>
<pre><code>type&lt;uint32-4bytes&gt;
length&lt;uint32-4bytes&gt;
parent_0_reference&lt;32bytes&gt;
parent_1_reference&lt;32bytes&gt;
transaction&lt;variable size&gt;
</code></pre>
<h3 id="utxo-1"><a class="header" href="#utxo-1">UTXO</a></h3>
<p>GoShimmer uses unspent transaction outputs (UTXOs) as inputs for transactions. Meaning that inputs reference a specific UTXO ID which was generated by a previous transaction. The UTXO ID is made up from the destination address plus the hash of the transaction creating the output.</p>
<h4 id="inputs"><a class="header" href="#inputs">Inputs</a></h4>
<p>As just described, an input is merely a reference to another transaction's output to a given address. GoShimmer currently works on addresses and unlike other cryptocurrencies does not yet have any concept of other unlocking mechanisms.</p>
<p>Addresses are BLAKE2b hashes of the corresponding Ed25519 and BLS public keys.</p>
<h4 id="outputs"><a class="header" href="#outputs">Outputs</a></h4>
<p>An output encapsulates a destination address, and a list of balances. A balance is an amount of tokens and a color.</p>
<h5 id="color--coloring"><a class="header" href="#color--coloring">Color &amp; Coloring</a></h5>
<p>The color of a balance is simply an array of 32 bytes and per default, tokens have a color of type &quot;IOTA&quot;, where all 32 bytes are zero.</p>
<p>Creating a new color involves specifying the special color type &quot;New&quot; in a transaction output, where each byte in the color array is set to 255. Doing this will instruct GoShimmer to then color the specific balance on the specific address of the given output to the hash of the transaction creating the output. New colors therefore simply equal the transaction hash of the transaction creating the output (and are therefore unique).</p>
<p>Coloring tokens does neither increase or decrease the token supply. It is up to merchants and other systems to provide meaning to the colors of tokens.</p>
<p>Because of the way the coloring works, any holder of colored tokens can &quot;shrink&quot; the circulating amount of the specific colored token by simply creating outputs again with the special color type &quot;New&quot;. Of course doing so will only effect the actual holder of the colored tokens but it is something to keep in mind when developing a system around colored tokens.</p>
<h3 id="transaction-2"><a class="header" href="#transaction-2">Transaction</a></h3>
<p>A transaction defines a transfer from UTXOs to new outputs.</p>
<p>It contains following properties:</p>
<ul>
<li>Inputs</li>
<li>Outputs</li>
<li>Payload</li>
<li>Signatures</li>
</ul>
<p>These properties minus the signatures make up the &quot;essence&quot; bytes of the transaction. Each signature signs the essence data. Therefore, if a transaction contains multiple inputs consuming UTXOs from an address, only one signature for that address needs to be provided.</p>
<p>A transaction is marked as solid when all of its referenced inputs are known.</p>
<p>A transaction’s byte layout is defined as:</p>
<pre><code>inputs_count&lt;uint32-4bytes&gt;
 (per input)-&gt;
     address&lt;33bytes&gt;
     utxo_id&lt;32bytes&gt;
     
outputs_count&lt;uint32-4bytes&gt;
 (per output)-&gt;
     address&lt;33bytes&gt;
     balances_count&lt;uint32-4bytes&gt;
      (per balance)-&gt;
          value&lt;int64-8bytes&gt;
          color&lt;32bytes&gt;
          
payload_length&lt;int32-8bytes&gt;
payload&lt;payload_length bytes&gt;

(signatures (multiple occurrences in any order))-&gt;
    (ED25519)-&gt;
        signature_type(1 byte, value = 1)
        public_key&lt;32bytes&gt;
        signature&lt;64bytes&gt;
    (BLS)-&gt;
        signature_type(1byte, value = 2)
        public_key&lt;128bytes&gt;
        signature&lt;64bytes&gt;
signature_block_end&lt;1byte, value 0&gt;
</code></pre>
<p>The payload length inside the transaction can be max 65KBs.</p>
<h3 id="parallel-reality-based-ledger-state"><a class="header" href="#parallel-reality-based-ledger-state">Parallel reality based ledger state</a></h3>
<p>GoShimmer uses the parallel reality based ledger state <a href="https://medium.com/@hans_94488/a-new-consensus-the-tangle-multiverse-part-1-da4cb2a69772">introduced by Hans in his blogpost series</a>. Unlike the blogpost however, conflict resolution is done via <a href="https://blog.iota.org/consensus-in-the-iota-tangle-fpc-b98e0f1e8fa">FPC</a>. There is also no notion of mana as of yet or 'partial liking' other opinion realities.</p>
<p>Note that the reason the ledger state is implemented this way is to make it easier to extend it for the multiverse consensus in case it becomes a viable choice.</p>
<h4 id="branches--realities"><a class="header" href="#branches--realities">Branches / Realities</a></h4>
<p>Realities are called branches in GoShimmer. A branch's ID is defined as a 32 byte long array. The master branch's ID is a 32 byte array where the first byte has the value 1.</p>
<p>Branches are created every time a conflict arises. The created branches have the IDs of the transactions which inflict/create the conflict.</p>
<p>Branches are in some sense a performance optimization as they allow to group transactions reflecting the same &quot;reality&quot; of ledger mutations as a group.</p>
<h5 id="conflict-detection"><a class="header" href="#conflict-detection">Conflict detection</a></h5>
<p>As mentioned, transactions use UTXO as inputs. Every time a transaction consumes a given output, the consumer count on the output is incremented. If the consumer count goes above 1, a conflict arises, since multiple transactions are trying to consume/use the same UTXO (double spend).</p>
<p>Note that in the case that there is yet no finalized/confirmed consumer of the UTXO, the transactions forming the conflict set each spawn their own branch. Likewise, if a transaction is the first consumer of an output, it doesn't create a new branch (may however generate an aggregated branch).</p>
<h5 id="aggregated-branches"><a class="header" href="#aggregated-branches">Aggregated Branches</a></h5>
<p>Since transactions are assigned to branches, transactions consuming outputs from transactions (which are non-conflicting) which reside in different branches, can create new so called aggregated branches. An aggregated branch is a virtual branch which reflects the change set of mutations of the ledger aggregated out of different branches.</p>
<h4 id="balances"><a class="header" href="#balances">Balances</a></h4>
<p>Making up the balances of a given address involves querying the node for UTXOs which have as a target the given address.</p>
<h3 id="consensus-1"><a class="header" href="#consensus-1">Consensus</a></h3>
<h4 id="fpc--fcob"><a class="header" href="#fpc--fcob">FPC &amp; FCoB</a></h4>
<p>We define a conflict as consuming (i.e., spending) more than once an (unspent) output. </p>
<p>Initially a node likes a transaction <code>v</code> that solidified at time <code>t</code> if in the interval <code>(−∞, t + avgNetworkDelay]</code> there are no spends from the same output (used as input).</p>
<p>If a conflicting transaction solidifies after that, we initially dislike it and add both (initially liked and initially disliked) conflicting transactions to the unresolved conflict set.</p>
<p>If no conflicting transactions solidify in the interval <code>(−∞, t + (2* avgNetworkDelay)]</code> we confirm (definitively like) <code>v</code>.</p>
<p>If <code>v_1,...,v_k</code> are all re-attachments of the same transaction, we either like all or none following the rule above.</p>
<p>Every <code>T</code> seconds a “Fast Probabilistic Consensus” (FPC) voting round is applied to every unresolved conflicting transaction in the Tangle:</p>
<ul>
<li>each node queries a set of randomly chosen nodes about its unresolved conflicting transactions; </li>
<li>the queried nodes send back their opinions on the requested transactions;</li>
</ul>
<p>After the FPC is done the values <code>g(v)</code> of several transactions may change and then it stays the same forever. 
That is, after the vote a transaction is either confirmed (definitely liked) or rejected (definitely disliked) by a node, and this value will never change. Further discussion about monotonicity appears below.</p>
<h4 id="monotonicity"><a class="header" href="#monotonicity">Monotonicity</a></h4>
<p>If <code>u</code> approves <code>v</code>, then <code>g(v) ≥ g(u)</code>, that is, if a node likes u then it likes any transaction <code>u</code> approves, and if the node dislikes <code>v</code> then it dislikes any transaction that approve <code>v</code>. </p>
<p>Another way of saying it is that if we like <code>v</code> then we like all of its past cone, and if we dislike <code>v</code> we dislike all of its future cone.
The votes of any node will follow the monotonicity rule.</p>
<h1 id="team-resources"><a class="header" href="#team-resources">Team resources</a></h1>
<h1 id="how-to-do-a-release"><a class="header" href="#how-to-do-a-release">How to do a release</a></h1>
<ol>
<li>Create a PR into <code>develop</code> updating the banner version (<code>plugins/banner.AppVersion</code>) and mentioning the changes in <code>CHANGELOG.md</code></li>
<li>Create a PR merging <code>develop</code> into <code>master</code></li>
<li>Create a release via the release page with the same changelog entries as in <code>CHANGELOG.md</code> for the given version tagging the <code>master</code> branch</li>
<li>Pray that the CI gods let the build pass</li>
<li>Check that the binaries are working</li>
<li>Stop the entry-node</li>
<li>Delete DB</li>
<li>Update version in docker-compose</li>
<li>Pull newest image</li>
<li>Start the node</li>
</ol>
<h1 id="code-guidelines"><a class="header" href="#code-guidelines">Code guidelines</a></h1>
<h2 id="general-guidelines"><a class="header" href="#general-guidelines">General guidelines</a></h2>
<ul>
<li>Don’t use <code>log.Fatal()</code> or <code>os.Exit()</code> outside of the main. It immediately terminates the program and all defers are ignored and no graceful shutdown is possible. It can lead to inconsistencies. Propagate the error up to the main and let the main function exit instead. Avoid panics as well, almost always use errors. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/autopeering/autopeering.go#L135">Example</a>.</li>
<li>Don’t duplicate code, reuse it. In tests too. Example: <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L969">duplicate1</a> and <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/packages/ledgerstate/branch_dag.go#L1053">duplicate2</a></li>
<li>Unhandled errors can cause bugs and make it harder to diagnose problems. Try to handle all errors: propagate them to the caller or log them. Even if the function call is used with a defer, and it’s inconvenient to handle the error it returns, still handle it. Wrap the function call in an anonymous function assign error to the upper error  like that:</li>
</ul>
<pre><code class="language-go">    defer func() {
        cerr := f.Close()
        if err == nil {
            err = xerrors.Errorf(&quot;failed to close file: %w&quot;, cerr)
        }
    }()
</code></pre>
<ul>
<li>Wrap errors with <code>xerrors.Errorf()</code> when returning them to the caller. It adds the stack trace and a custom message to the error. Without that information investigating an issue is very hard.</li>
<li>Use <code>xerrors.Is()</code> instead of direct errors comparison. This function unwraps errors recursively. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-05fdc081489a8d5a61224d812f9bbd7bc77edf9769ed00d95ea024d2a44a699aL62">Example</a>.</li>
<li>Propagate <code>ctx</code> and use APIs that accept <code>ctx</code>, start exposing APIs that accept <code>ctx</code>. Context is a native way for timeouts/cancellation in Go. It allows writing more resilient and fault tolerant code. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f2820ed0d3d4d9ea05b78b1dd3978dbcf9401c8caaa8cc40cc1c0342a55379fcL35">Example</a>.</li>
<li>Don’t shadow builtin functions like copy, len, new etc. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-f07268750a44da26386469c1b1e93574a678c3d418fce9e1f186d5f1991a92eaL14">Example</a>.</li>
<li>Don’t shadow imported packages. <a href="https://github.com/iotaledger/goshimmer/blob/f75ce47eeaa3bf930b368754ac24b72f768a5964/plugins/webapi/value/sendtransactionbyjson.go#L172">Example</a>.</li>
<li>Don’t do <code>[:]</code> on a slice. It has no effect. <a href="https://github.com/iotaledger/goshimmer/pull/1113/files#diff-299a1ac5fa09739ea07b7c806ee2785d83eea110f8af143dbc853a25e4819116L133">Example</a>.</li>
<li>Avoid naked returns if the function isn’t very small. It makes the code more readable.</li>
<li>Define explicit constants for strings that are used 3 times or more. It makes the code more maintainable.</li>
<li>Define explicit constants for all numbers. It makes the code more readable.</li>
<li>Don’t write really long and complex functions. Split them into smaller ones.</li>
<li>Treat comments as regular text/documentation. Start with a capital letter, set space after <code>//</code> and end them with a dot. It’s a good habit since Go package docs are generated automatically from the comments and displayed on the godoc site.</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>We use the new error wrapping API and behavior introduced with Go 1.13 but we use the &quot;golang.org/x/xerrors&quot; drop-in replacement which follows the Go 2 design draft and which enables us to have a stack trace for every &quot;wrapping&quot; of the error.</p>
<p>Errors should always be wrapped an annotated with an additional message at each step. The following example shows how errors are wrapped and turned into the corresponding sentinel errors.</p>
<pre><code class="language-go">package example

import (
    &quot;errors&quot;
    &quot;3rdPartyLibrary&quot;

    &quot;golang.org/x/xerrors&quot;
)

// define error variables to make errors identifiable (sentinel errors)
var ErrSentinel = errors.New(&quot;identifiable error&quot;)

// turn anonymous 3rd party errors into identifiable ones
func SentinelErrFrom3rdParty() (result interface{}, err error)
    if result, err = 3rdPartyLibrary.DoSomething(); err != nil {
        err = xerrors.Errorf(&quot;failed to do something (%v): %w&quot;, err, ErrSentinel)
        return
    }

    return
}

// wrap recursive errors at each step
func WrappedErrFromInternalCall() error {
    return xerrors.Errorf(&quot;wrapped internal error: %w&quot;, SentinelErrFrom3rdParty())
}

// create &quot;new&quot; identifiable internal errors that are not originating in 3rd party libs
func ErrFromInternalCall() error {
    return xerrors.Errorf(&quot;internal error: %w&quot;, ErrSentinel)
}

// main function
func main() {
    err1 := WrappedErrFromInternalCall()
    if xerrors.Is(err1, ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err1)
    }

    err2 := ErrFromInternalCall()
    if xerrors.Is(err2 , ErrSentinel) {
        fmt.Printf(&quot;%v\n&quot;, err2 )
    }
}
</code></pre>
<h1 id="golangci-lint"><a class="header" href="#golangci-lint">golangci-lint</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>We use golangci-lint v1.38.0 to run various types of linters on our codebase. All settings are stored in the <code>.golangci.yml</code> file.
golangci-lint is very flexible and customizable. Check the docs to see how configuration works https://golangci-lint.run/usage/configuration/</p>
<h2 id="how-to-run-1"><a class="header" href="#how-to-run-1">How to run</a></h2>
<ol>
<li>Install the golangci-lint program https://golangci-lint.run/usage/install/</li>
<li>In the project root: <code>golangci-lint run</code></li>
</ol>
<h2 id="dealing-with-errors"><a class="header" href="#dealing-with-errors">Dealing with errors</a></h2>
<p>Most of the errors that golangci-lint reports are errors from formatting linters like <code>gofmt</code>, <code>goimports</code> and etc. You can easily auto-fix them with:</p>
<pre><code>golangci-lint run --fix
</code></pre>
<p>Here is the full list of linters that support the auto-fix feature: <code>gofmt</code>, <code>gofumpt</code>, <code>goimports</code>, <code>misspell</code>, <code>whitespace</code>.</p>
<p>In case it's not a formatting error, do your best to fix it first. If you think it's a false alarm there are a few ways how to disable that check in golangci-lint:</p>
<ul>
<li>Exclude the check by the error text regexp. Example: <code>'Error return value of .((os\.)?std(out|err)\..*|.*Close|.*Flush|os\.Remove(All)?|.*print(f|ln)?|os\.(Un)?Setenv). is not checked'</code>.</li>
<li>Exclude the entire linter for that file type. Example: don't run <code>errcheck</code> in Go test files.</li>
<li>Change linter settings to make it more relaxed. </li>
<li>Disable that particular error occurrence: use a comment with a special <code>nolint</code> directive next to the place in code with the error. Example: <code>// nolint: errcheck</code>.</li>
</ul>
<h1 id="docker-1"><a class="header" href="#docker-1">Docker</a></h1>
<h2 id="building-image"><a class="header" href="#building-image">Building image</a></h2>
<p>We use the new buildkit docker engine to build <code>iotaledger/goshimmer</code> image. 
The minimum required docker version that supports this feature is <code>18.09</code>. 
To enable buildkit engine in your local docker add the following to the docker configuration json file:</p>
<pre><code class="language-json">{ &quot;features&quot;: { &quot;buildkit&quot;: true } }
</code></pre>
<p>Check this <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#to-enable-buildkit-builds">article</a> for details on how to do that.</p>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<p>If you are getting an error like that during the docker build:</p>
<pre><code class="language-dockerfile">Step 10/17 : RUN --mount=target=.     --mount=type=cache,target=/root/.cache/go-build     CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh
 ---&gt; Running in ecdae1c9339d
no Go files in /goshimmer
/bin/sh: 1: ./check_static.sh: not found
The command '/bin/sh -c CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build     -ldflags='-w -s -extldflags &quot;-static&quot;'     -o /go/bin/goshimmer;     ./check_static.sh' returned a non-zero code: 127
</code></pre>
<p>It means that buildkit feature doesn't work in your docker. 
If you already enabled it in the configuration json file as described above and docker version is <code>18.09</code> or higher, 
try to set the following env variables when building the docker image:</p>
<pre><code>DOCKER_BUILDKIT=1 COMPOSE_DOCKER_CLI_BUILD=1 docker build -t iotaledger/goshimmer .
</code></pre>
<h1 id="goshimmer-analysis-dashboard"><a class="header" href="#goshimmer-analysis-dashboard">GoShimmer Analysis Dashboard</a></h1>
<p>Programmed using modern web technologies.</p>
<h3 id="dashboard-in-dev-mode"><a class="header" href="#dashboard-in-dev-mode">Dashboard in dev mode</a></h3>
<ol>
<li>Make sure to set <code>analysis.dashboard.dev</code> to true, to enable GoShimmer to serve assets
from the webpack-dev-server.</li>
<li>Install all needed npm modules via <code>yarn install</code>.</li>
<li>Run a webpack-dev-server instance by running <code>yarn start</code> within the <code>frontend</code> directory.</li>
<li>Using default port config, you should now be able to access the analysis dashboard under http://127.0.0.1:8000</li>
</ol>
<p>The Analysis Dashboard is hot-reload enabled.</p>
<h3 id="pack-your-changes"><a class="header" href="#pack-your-changes">Pack your changes</a></h3>
<p>We are using <a href="https://github.com/gobuffalo/packr/tree/master/v2">packr2</a> to wrap all built frontend files into Go files.</p>
<ol>
<li>
<p><a href="https://github.com/gobuffalo/packr/tree/master/v2#binary-installation">Install <code>packr2</code></a> if not already done.</p>
</li>
<li>
<p>Check that the correct webpack-cli (version v3.3.11) is installed: </p>
<p>2.1 <code>yarn webpack-cli --version</code></p>
<p>2.2 If a newer version is installed use <code>yarn remove webpack-cli</code> and <code>yarn add webpack-cli@3.3.11</code> </p>
</li>
<li>
<p>Build Analysis Dashboard by running <code>yarn build</code> within the <code>frontend</code> directory.</p>
</li>
<li>
<p>Navigate to the root of the repo.</p>
</li>
<li>
<p>Run <code>pkger</code> in the root of the repo.</p>
</li>
<li>
<p><code>pkged.go</code> should have been modified.</p>
</li>
<li>
<p>Done. Now you can build goShimmer and your Analysis Dashboard changes will be included within the binary.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
