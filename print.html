<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOTA GoShimmer</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="goshimmer.html"><strong aria-hidden="true">1.</strong> GoShimmer</a></li><li class="chapter-item expanded "><a href="application_logic.html"><strong aria-hidden="true">2.</strong> Application logic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="application_logic/protocol.html"><strong aria-hidden="true">2.1.</strong> Protocol high level overview</a></li></ol></li><li class="chapter-item expanded "><a href="implementation_design.html"><strong aria-hidden="true">3.</strong> Implementation design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="implementation_design/event_driven_model.html"><strong aria-hidden="true">3.1.</strong> Event driven model</a></li><li class="chapter-item expanded "><a href="implementation_design/packages_plugins.html"><strong aria-hidden="true">3.2.</strong> Packages and plugins</a></li><li class="chapter-item expanded "><a href="implementation_design/configuration_parameters.html"><strong aria-hidden="true">3.3.</strong> Configuration parameters</a></li><li class="chapter-item expanded "><a href="implementation_design/plugin.html"><strong aria-hidden="true">3.4.</strong> Plugin</a></li><li class="chapter-item expanded "><a href="implementation_design/object_storage.html"><strong aria-hidden="true">3.5.</strong> Object storage</a></li></ol></li><li class="chapter-item expanded "><a href="apis/webAPI_clientLib.html"><strong aria-hidden="true">4.</strong> WebAPI - clientLib</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="apis/mana.html"><strong aria-hidden="true">4.1.</strong> Mana</a></li></ol></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">5.</strong> Tooling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/docker_private_network.html"><strong aria-hidden="true">5.1.</strong> Docker private network</a></li></ol></li><li class="chapter-item expanded "><a href="specification.html"><strong aria-hidden="true">6.</strong> Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/001-mana_proposal.html"><strong aria-hidden="true">6.1.</strong> Mana Proposal</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">IOTA GoShimmer</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/iotaledger/goshimmer" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the GoShimmer docs!</p>
<p>GoShimmer is a prototype node software exploring the implementation of <a href="https://coordicide.iota.org/">the Coordicide project</a>. This docs help the reader to understand the basic concepts and ideas behind the Coordicide and how its modules are implemented in GoShimmer.</p>
<h1 id="application-logic"><a class="header" href="#application-logic">Application logic</a></h1>
<h1 id="protocol-high-level-overview"><a class="header" href="#protocol-high-level-overview">Protocol high level overview</a></h1>
<p>will link (in the future) to specific specs</p>
<ul>
<li>Overall data flow might help here</li>
</ul>
<h1 id="implementation-design"><a class="header" href="#implementation-design">Implementation design</a></h1>
<h1 id="event-driven-model"><a class="header" href="#event-driven-model">Event driven model</a></h1>
<p>Event driven model is popular approach often used for example in GUI applications, where a program is waiting for some external event to take place (e.g. mouse click) in order to perform some action.
In case of GoShimmer there is no GUI, however it applies this architecture approach as it's really flexible and is used to handle communication with other nodes and other internal parts. 
In GoShimmer some of those events can be e.g. arrival of new tangle message, peering request or plugin start. 
When an event is triggered, an event handler (or a collection of handlers) is executed and the state of the application is updated as necessary.</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary:</a></h2>
<p>At first let's define some terms used further to avoid misunderstandings:</p>
<ul>
<li>
<p>Event - represents the type of event (e.g. new message or peering request) as well as set of handlers and trigger functions. Each type of event is separately defined 
which means that events are independent of each other - each event has its own set of handlers and is triggered separately.</p>
</li>
<li>
<p>Event handler (callback) - is a function that is executed when an event of given type occurs. An event handler can accept multiple arguments (e.g. message ID or plugin) so that it can perform appropriate actions.
Every handler must accept the same set of parameters. Each event has a different set of handlers (there can be multiple handlers) that are executed when the event is triggered.</p>
</li>
<li>
<p>Trigger - is a method that triggers execution of event handlers with given parameter values.</p>
</li>
</ul>
<h2 id="creating-new-event-with-custom-callbacks"><a class="header" href="#creating-new-event-with-custom-callbacks">Creating new event with custom callbacks</a></h2>
<p>Below are the steps that show the example code necessary to create a custom event, attach a handler and trigger the event. </p>
<ol>
<li>Create a function that will call event handlers (handler caller) for a specific event. 
Each event has only one handler caller. It enforces that all handlers for the event must share the same interface, because the caller will pass a fixed set of arguments of specific types to handler function. 
It's not possible to pass different number of arguments or types to the handler function. 
Callers for all events must also share the same interface - the first argument represents the handler function that will be called represented by a generic argument.
Further arguments represent parameters that will be passed to the handler during execution. Below are example callers that accept one and two parameters respectively. 
More arguments can be passed in similar manner. </li>
</ol>
<pre><code class="language-go">func singleArgCaller(handler interface{}, params ...interface{}) {
    handler.(func (*Plugin))(params[0].(*Plugin))
}

func twoArgsCaller(handler interface{}, params ...interface{}) {
    handler.(func(*peer.Peer, error))(params[0].(*peer.Peer), params[1].(error))
}
</code></pre>
<p><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - this code seems a little complicated, so to make things simpler we will divide into smaller parts and explain each:</p>
<ul>
<li><code>handler.(func (*Plugin))</code> (A) - this part does type-cast the handler from generic type onto type of desired, specific function type - in this case it's a function that accepts <code>*Plugin</code> as its only parameter.</li>
<li><code>params[0].(*Plugin)</code> (B)- similarly to previous part, first element of parameter slice is type-casted onto <code>*Plugin</code> type, so that it matches the handler function interface.</li>
<li><code>handler.(func (*Plugin))(params[0].(*Plugin))</code> - the whole expression calls the type-casted handler function with the type-casted parameter value. We can also write this as <code>A(B)</code> to make things simpler.</li>
</ul>
<p>The above explanation also allows a better understanding of why all handlers must share the same interface - handler caller passes fixed number of parameters and does type-casting of arguments onto specific types.</p>
<ol start="2">
<li>Next, a new event object needs to be created. We pass the handler caller as an argument, which is saved inside the object to be called when the event is triggered.</li>
</ol>
<pre><code class="language-go">import &quot;github.com/iotaledger/hive.go/events&quot;

ThisEvent := events.NewEvent(singleArgCaller)
</code></pre>
<ol start="3">
<li>After creating the event, handlers (or callbacks) can be attached to it. An event can have multiple callbacks, however they all need to share the same interface. 
One thing to note, is that functions are not passed directly - first they are wrapped into a <code>events.Closure</code> object like in the example below. </li>
</ol>
<pre><code class="language-go">ThisEvent.Attach(events.NewClosure(func (arg *Plugin) {
    // do something
}))
</code></pre>
<ol start="4">
<li>In order to trigger the event with some parameters we need to run the <code>.Trigger</code> method on the event object with parameters that handler functions will receive:</li>
</ol>
<pre><code class="language-go">somePlugin Plugin
ThisEvent.Trigger(&amp;somePlugin)
</code></pre>
<h1 id="packages-and-plugins"><a class="header" href="#packages-and-plugins">Packages and plugins</a></h1>
<h1 id="configuration-parameters"><a class="header" href="#configuration-parameters">Configuration parameters</a></h1>
<h1 id="plugin-system"><a class="header" href="#plugin-system">Plugin system</a></h1>
<p>GoShimmer is a complex application that is used in a research environment where requirements often changed and new ideas arise. 
The Plugin system allows to quickly and easily add and remove modules that need to be started. However, one thing that might be non-intuitive about the use of plugins is that it's taken to an extreme - everything is run through plugins. 
The only code that is not executed through a plugin system is the code responsible for configuring and starting the plugins.
All new future features added to the GoShimmer must be added by creating a new plugin. </p>
<h2 id="plugin-structure"><a class="header" href="#plugin-structure">Plugin structure</a></h2>
<p><code>Plugin</code> structure is defined as following.</p>
<pre><code class="language-go">type Plugin struct {
	Node   *Node
	Name   string
	Status int
	Events pluginEvents
	wg     *sync.WaitGroup
}
</code></pre>
<p>Below is a brief description of each field: </p>
<ul>
<li><code>Node</code> - contains a pointer to <code>Node</code> object which contains references to all the plugins and node-level logger. #TODO: figure out why it is there - not really used anywhere</li>
<li><code>Name</code> - descriptive name of the plugin.</li>
<li><code>Status</code> - flag indicating whether plugin is enabled or disabled.</li>
<li><code>Events</code> - structure containing events used to properly deploy the plugin. Details described below.</li>
<li><code>wg</code> - a private field containing WaitGroup. #TODO: figure out why it is there - not really used anywhere</li>
</ul>
<h2 id="plugin-events"><a class="header" href="#plugin-events">Plugin events</a></h2>
<p>Each plugin defines 3 events: <code>Init</code>, <code>Configure</code>, <code>Run</code>. 
Those events are triggered during different stages of node startup, but the plugin doesn't have to define handlers for all of those events in order to do what it's been designed for.
Execution order and purpose of each event is described below: </p>
<ol>
<li><code>Init</code> - is triggered almost immediately after a node is started. It's used in plugins that are critical for GoShimmer such as reading config file or initializing global logger. Most plugins don't need to use this event.</li>
<li><code>Configure</code> - this event is used to configure the plugin before it is started. It is used to define events related to internal plugin logic or initialize objects used by the plugin. </li>
<li><code>Run</code> - this event is triggered as the last one. The event handler function contains the main logic of the plugin. 
For many plugins, the event handler function creates a separate worker that works in the background, so that the handler function for one plugin can finish and allow other plugins to be started.</li>
</ol>
<p>Each event could potentially have more than one handler, however currently all existing plugins follow a convention where each event has only one handler.</p>
<p>It is important to note that each event is triggered for all plugins sequentially, so that the event <code>Init</code> is triggered for all plugins, then <code>Configure</code> is triggered for all plugins and finally <code>Run</code>. 
Such order is crucial, because some plugins rely on other plugins' initialization or configuration. The order in which plugins are initialized, configured and run is also important and this is described below. </p>
<p>Handler functions for all plugin events share the same interface, so they could potentially be used interchangeably. Sample handler functions look like this:</p>
<pre><code class="language-go">func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) { 
    // run plugin	
}
</code></pre>
<p>The handler functions receive one argument of type <code>*Plugin</code>. The code responsible for triggering those events passes a pointer to the plugin object itself. 
The object needs to be passed so that the handler function can access plugin fields (e.g. plugin name to configure logger).</p>
<h2 id="creating-new-plugin"><a class="header" href="#creating-new-plugin">Creating new plugin</a></h2>
<p>A plugin object can be created by calling the <code>node.NewPlugin</code> method. 
The method creates and returns a new plugin object, as well as registers it so that GoShimmer knows the plugin is available.
It accepts the following arguments:</p>
<ul>
<li><code>name string</code> - plugin name.</li>
<li><code>status int</code> - flag indicating whether plugin is enabled or disabled by default. This can be overridden by enabling/disabling the plugin in the external configuration file. Possible values: <code>node.Enabled</code>, <code>node.Disabled</code>. </li>
<li><code>callbacks ...Callback</code> - list of event handler functions. The method will correctly create a plugin when passing up to 2 callbacks. Note: <code>type Callback = func(plugin *Plugin)</code>, which is a raw function type without being wrapped in <code>events.Closure</code>.</li>
</ul>
<p>There is a couple of ways that the method can be called, depending on which plugin events need to be configured. </p>
<ul>
<li>Define <code>Configure</code> and <code>Run</code> event handlers. It's the most common usage that plugins currently use. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
</code></pre>
<ul>
<li>Define only <code>Configure</code> event. It's used for plugins that are used to configure objects used (or managed) by other plugins, such as creating API endpoints. </li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled, configure)
</code></pre>
<ul>
<li>Define a plugin without <code>Configure</code> or <code>Run</code> event handlers. This is used to create plugins that perform some action when the <code>Init</code> event is triggered.</li>
</ul>
<pre><code class="language-go">plugin = node.NewPlugin(PluginName, node.Enabled)
</code></pre>
<p>However, the <code>Init</code> event handler cannot be attached using the <code>node.NewPlugin</code> method. 
In order to specify this handler, plugin creator needs to attach it manually to the event, for example inside the package's <code>init()</code> method in the file containing the rest of the plugin definition.</p>
<pre><code class="language-go">func init() {
	plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
		// do something
	}))
}
</code></pre>
<p>It's important to note, that the <code>node.NewPlugin</code> accepts handler functions in a raw format, that is, without being wrapped by the <code>events.Closure</code> object as the method does the wrapping inside.
However, when attaching the <code>Init</code> event handler manually, it must be wrapped by the <code>events.Closure</code> object. </p>
<p>It's crucial that each plugin is created only once and <code>sync.Once</code> class is used to guarantee that. Contents of a file containing sample plugin definition is presented. All plugins follow this format.</p>
<pre><code class="language-go">const PluginName = &quot;SamplePlugin&quot;

var (
	// plugin is the plugin instance of the new plugin plugin.
	plugin     *node.Plugin
	pluginOnce sync.Once
)

// Plugin gets the plugin instance.
func Plugin() *node.Plugin {
	pluginOnce.Do(func() {
		plugin = node.NewPlugin(PluginName, node.Enabled, configure, run)
	})
	return plugin
}

// Handler functions
func init() {
    plugin.Events.Init.Attach(events.NewClosure(func(*node.Plugin) {
        // do something
    }))
}
func configure(_ *node.Plugin) {
    // configure stuff
}

func run(*node.Plugin) {
    // run stuff	
}
</code></pre>
<h2 id="running-new-plugin"><a class="header" href="#running-new-plugin">Running new plugin</a></h2>
<p>In order to correctly add a new plugin to GoShimmer, apart from defining it, it must also be passed to the <code>node.Run</code> method. 
Because there are plenty of plugins, in order to improve readability and make managing plugins easier, they are grouped into separate wrappers passed to the <code>node.Run</code> method. 
When adding a new plugin, it must be added into one of those groups, or a new group must be created.</p>
<pre><code class="language-go">node.Run(
    plugins.Core,
    plugins.Research,
    plugins.UI,
    plugins.WebAPI,
)
</code></pre>
<p>You can add a plugin simply by calling the <code>Plugin()</code> method of the newly created plugin and passing the argument further. An example group definition is presented below. When it's added, the plugin is correctly added and will be run when GoShimmer starts.</p>
<pre><code class="language-go">var Core = node.Plugins(
    banner.Plugin(),
    newPlugin.Plugin(),
    // other plugins ommited 
)
</code></pre>
<h2 id="background-workers"><a class="header" href="#background-workers">Background workers</a></h2>
<p>In order to run plugins beyond the scope of the short-lived <code>Run</code> event handler, possibly multiple <code>daemon.BackgroundWorker</code> instances can be started inside the handler function. 
This allows the <code>Run</code> event handler to finish quickly, and the plugin logic can continue running concurrently in a separate goroutine. </p>
<p>Background worker can be started by running the <code>daemon.BackgroundWorker</code> method, which accepts following arguments:</p>
<ul>
<li><code>name string</code> - background worker name</li>
<li><code>handler WorkerFunc</code> - long-running function that will be started in its own goroutine. It accepts a single argument of type <code>&lt;-chan struct{}</code>. When something is sent to that channel, the worker will shut down. Note: <code>type WorkerFunc = func(shutdownSignal &lt;-chan struct{})</code></li>
<li><code>order ...int</code> - value used to define in which shutdown order this particular background worker must be shut down (higher = earlier).
The parameter can either accept one or zero values, more values will be ignored. When passing zero values, default value of <code>0</code> is assumed.
Values are normalized in the <code>github.com/iotaledger/goshimmer/packages/shutdown</code> package, and it should be used instead of passing integers manually. 
Correct shutdown order is as important as correct start order, because different plugins depend on others working correctly, so when one plugin shuts down too soon, other plugins may run into errors, crash and leave an incorrect state. </li>
</ul>
<p>An example code for creating a background worker: </p>
<pre><code class="language-go">func start(shutdownSignal &lt;-chan struct{}) {
	// long-running function
	// possibly start goroutines here
	// wait for shutdown signal
    &lt;-shutdownSignal
}

if err := daemon.BackgroundWorker(backgroundWorkerName, start, shutdown.PriorityGossip); err != nil {
	log.Panicf(&quot;Failed to start as daemon: %s&quot;, err)
}
</code></pre>
<h1 id="object-storage"><a class="header" href="#object-storage">Object storage</a></h1>
<h1 id="webapi---clientlib"><a class="header" href="#webapi---clientlib">WebAPI - clientLib</a></h1>
<p>The web API interface allows to access functionality of the node software via exposed http endpoints.</p>
<h2 id="how-to-use-the-api"><a class="header" href="#how-to-use-the-api">How to use the API</a></h2>
<p>The default port to access the web API is set to <code>8080:8080/tcp</code> in <code>docker-compose.yml</code>, where the first port number is the internal port number within the node software, and the second for the access from an http port. An example where these two would be set to different values, or the external port is not utilized, can be found in the docker-network tool (see also the <code>docker-compose.yml</code> file in the docker-network tool folder).</p>
<p>The server instance of the web API is contacted via <code>webapi.Server()</code>. Next we need to register a route with a matching handler.</p>
<pre><code>webapi.Server().ROUTE(path string, h HandlerFunc)
</code></pre>
<p>where <code>ROUTE</code> will be replaced later in this documentation by <code>GET</code> or <code>POST</code>. The <code>HandlerFunc</code> defines a function to serve HTTP requests that gives access to the Context</p>
<pre><code>func HandlerFunc(c Context) error
</code></pre>
<p>We can then use the Context to send a JSON response to the node: </p>
<pre><code>JSON(statuscode int, i interface{}) error
</code></pre>
<p>An implementation example is shown later for the POST method.</p>
<h2 id="get-and-post"><a class="header" href="#get-and-post">GET and POST</a></h2>
<p>Two methods are currently used. First, with <code>GET</code> we register a new GET route for a handler function. The handler is accessed via the address <code>path</code>. The handler for a GET method can set the node to perform certain actions.</p>
<pre><code>webapi.Server().GET(&quot;path&quot;, HandlerFunc)
```	
A command can be sent to the node software to the API, e.g. via command prompt: 
</code></pre>
<p>curl &quot;http://127.0.0.1:8080/path?command&quot;</p>
<pre><code>
$$ . $$

Second, with `POST` we register a new POST route for a handler function. The handler can receive a JSON body input and send specific messages to the tangle.
</code></pre>
<p>webapi.Server().POST(&quot;path&quot;, HandlerFunc)</p>
<pre><code>
For example, the following Handler `broadcastData` sends a data message to the tangle
</code></pre>
<p>func broadcastData(c echo.Context) error {
var request Request
if err := c.Bind(&amp;request); err != nil {
log.Info(err.Error())
return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}</p>
<pre><code>msg, err := messagelayer.IssuePayload(
	payload.NewGenericDataPayload(request.Data), messagelayer.Tangle())
if err != nil {
	return c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
}
return c.JSON(http.StatusOK, Response{ID: msg.ID().String()})
</code></pre>
<p>}</p>
<pre><code>As an example the JSON body   
</code></pre>
<p>{
&quot;data&quot;:&quot;HelloWor&quot;
}</p>
<pre><code>can be sent to `http://127.0.0.1:8080/data`, which will issue a data message containing &quot;HelloWor&quot; (note that in this  example the data input is size limited.)
 
</code></pre>
<h1 id="mana-api-methods"><a class="header" href="#mana-api-methods">Mana API Methods</a></h1>
<p>The mana APIs provide methods for people to retrieve the amount of access/consensus mana of nodes and outputs, as well as the event logs.</p>
<p>HTTP APIs:</p>
<ul>
<li><a href="apis/mana.html#mana">/mana</a></li>
<li><a href="apis/mana.html#manaall">/mana/all</a></li>
<li><a href="apis/mana.html#manapercentile">/mana/percentile</a></li>
<li><a href="apis/mana.html#manaaccessonline">/mana/access/online</a></li>
<li><a href="apis/mana.html#manaconsensusonline">/mana/consensus/online</a></li>
<li><a href="apis/mana.html#manaaccessnhighest">/mana/access/nhighest</a></li>
<li><a href="apis/mana.html#manaconsensusnhighest">/mana/consensus/nhighest</a></li>
<li><a href="apis/mana.html#manapending">/mana/pending</a></li>
<li><a href="apis/mana.html#manaconsensuspast">/mana/consensus/past</a></li>
<li><a href="apis/mana.html#manaconsensuslogs">/mana/consensus/logs</a></li>
<li><a href="apis/mana.html#valueallowedmanapledge">/value/allowedManaPledge</a></li>
</ul>
<p>Client lib APIs:</p>
<ul>
<li><a href="apis/mana.html#getownmana">GetOwnMana()</a></li>
<li><a href="apis/mana.html#getmanafullnodeid">GetManaFullNodeID()</a></li>
<li><a href="apis/mana.html#getmana-with-short-node-id">GetMana with short node ID()</a></li>
<li><a href="apis/mana.html#client-lib---getallmana">GetAllMana()</a></li>
<li><a href="apis/mana.html#client-lib---getmanapercentile">GetManaPercentile()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineaccessmana">GetOnlineAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getonlineconsensusmana">GetOnlineConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestaccessmana">GetNHighestAccessMana()</a></li>
<li><a href="apis/mana.html#client-lib---getnhighestconsensusmana">GetNHighestConsensusMana()</a></li>
<li><a href="apis/mana.html#client-lib---getpending">GetPending()</a></li>
<li><a href="apis/mana.html#client-lib---getpastconsensusmanavector">GetPastConsensusManaVector()</a></li>
<li><a href="apis/mana.html#client-lib---getconsensuseventlogs">GetConsensusEventLogs()</a></li>
<li><a href="apis/mana.html#client-lib---getallowedmanapledgenodeids">GetAllowedManaPledgeNodeIDs()</a></li>
</ul>
<h2 id="mana"><a class="header" href="#mana"><code>/mana</code></a></h2>
<p>Get the access and consensus mana of the node.</p>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<table><thead><tr><th><strong>Parameter</strong></th><th><code>node ID</code></th></tr></thead><tbody>
<tr><td><strong>Required or Optional</strong></td><td>optional</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h4 id="note"><a class="header" href="#note"><strong>Note</strong></a></h4>
<p>If no node ID is given, it returns the access and consensus mana of the node you're communicating with.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="curl"><a class="header" href="#curl">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib"><a class="header" href="#client-lib">client lib</a></h4>
<p>There are 3 APIs to get mana of a node, which is based on the same HTTP API <code>/mana</code>.</p>
<h5 id="getownmana"><a class="header" href="#getownmana"><code>GetOwnMana</code></a></h5>
<p>Get the access and consensus mana of the node this API client is communicating with.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetOwnMana()
if err != nil {
    // return error
}

// print the node ID
fmt.Println(&quot;full ID: &quot;, manas.NodeID, &quot;short ID: &quot;, manas.ShortNodeID)

// get access mana of the node
fmt.Println(&quot;access mana: &quot;, manas.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)

// get consensus mana of the node
fmt.Println(&quot;consensus mana: &quot;, manas.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h5 id="getmanafullnodeid"><a class="header" href="#getmanafullnodeid"><code>GetManaFullNodeID</code></a></h5>
<p>Get Mana of a node with its full node ID.</p>
<pre><code class="language-go">manas, err := goshimAPI.GetManaFullNodeID(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}
</code></pre>
<h5 id="getmana-with-short-node-id"><a class="header" href="#getmana-with-short-node-id"><code>GetMana</code> with short node ID</a></h5>
<pre><code class="language-go">manas, err := goshimAPI.GetMana(&quot;4AeXyZ26e4G&quot;)
if err != nil {
    // return error
}
</code></pre>
<h3 id="response-examples"><a class="header" href="#response-examples">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 26.5,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 26.5,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaall"><a class="header" href="#manaall"><code>/mana/all</code></a></h2>
<p>Get the mana perception of the node in the network. You can retrieve the full/short node ID, consensus mana, access mana of each node, and the mana updated time.</p>
<h3 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<h4 id="curl-1"><a class="header" href="#curl-1">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/all \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallmana"><a class="header" href="#client-lib---getallmana">client lib - <code>GetAllMana()</code></a></h4>
<pre><code class="language-go">manas, err := goshimAPI.GetAllMana()
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)

// get access mana of each node
for _, m := range manas.Access {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;access mana: &quot;, m.Mana)
}

// get consensus mana of each node
for _, m := range manas.Consensus {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;short node ID:&quot;, m.ShortNodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-1"><a class="header" href="#response-examples-1">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;access&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: [
      {
          &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
          &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
          &quot;mana&quot;: 26.5
      }
  ],
  &quot;consensusTimestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>access</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">A list of node that has access mana.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr"><a class="header" href="#mananodestr"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapercentile"><a class="header" href="#manapercentile"><code>/mana/percentile</code></a></h2>
<p>To learn the top percentile the node belongs to relative to the network in terms of mana. The input should be a full node ID.</p>
<h3 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>node ID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>full node ID</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples</a></h3>
<h4 id="curl-2"><a class="header" href="#curl-2">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/percentile?2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getmanapercentile"><a class="header" href="#client-lib---getmanapercentile">client lib - <code>GetManaPercentile()</code></a></h4>
<pre><code class="language-go">mana, err := goshimAPI.GetManaPercentile(&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;)
if err != nil {
    // return error
}

// mana updated time
fmt.Println(&quot;access mana percentile: &quot;, mana.Access, &quot;access mana updated time: &quot;, manas.AccessTimestamp)
fmt.Println(&quot;consensus mana percentile: &quot;, mana.Consensus, &quot;consensus mana updated time: &quot;, manas.ConsensusTimestamp)
</code></pre>
<h3 id="response-examples-2"><a class="header" href="#response-examples-2">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
  &quot;access&quot;: 75,
  &quot;accessTimestamp&quot;: 1614924295,
  &quot;consensus&quot;: 75,
  &quot;consensusTimestamp&quot;: 1614924295,
}
</code></pre>
<h3 id="results-2"><a class="header" href="#results-2">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>access</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>accessTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of access mana updates.</td></tr>
<tr><td align="left"><code>consensus</code></td><td align="left">float64</td><td align="left">Access mana percentile of a node.</td></tr>
<tr><td align="left"><code>consensusTimestamp</code></td><td align="left">int64</td><td align="left">The timestamp of consensus mana updates.</td></tr>
</tbody></table>
<h2 id="manaaccessonline"><a class="header" href="#manaaccessonline"><code>/mana/access/online</code></a></h2>
<p>You can get a sorted list of online access mana of nodes, sorted from the highest access mana to the lowest. The highest access mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples</a></h3>
<h4 id="curl-3"><a class="header" href="#curl-3">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineaccessmana"><a class="header" href="#client-lib---getonlineaccessmana">client lib - <code>GetOnlineAccessMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineAccessMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;access mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-3"><a class="header" href="#response-examples-3">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-3"><a class="header" href="#results-3">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The access mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr"><a class="header" href="#onlinenodestr"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusonline"><a class="header" href="#manaconsensusonline"><code>/mana/consensus/online</code></a></h2>
<p>You can get a sorted list of online consensus mana of nodes, sorted from the highest consensus mana to the lowest. The highest consensus mana node has OnlineRank 1, and increases 1 by 1 for the following nodes.</p>
<h3 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<h4 id="curl-4"><a class="header" href="#curl-4">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/online \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getonlineconsensusmana"><a class="header" href="#client-lib---getonlineconsensusmana">client lib - <code>GetOnlineConsensusMana()</code></a></h4>
<pre><code class="language-go">// online access mana
accessMana, err := goshimAPI.GetOnlineConsensusMana()
if err != nil {
    // return error
}

for _, m := accessMana.Online {
    fmt.Println(&quot;full node ID: &quot;, m.ID, &quot;mana rank: &quot;, m.OnlineRank, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-4"><a class="header" href="#response-examples-4">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;online&quot;: [
      {
        &quot;rank&quot;: 1,
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 75
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-4"><a class="header" href="#results-4">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>online</code></td><td align="left">OnlineNodeStr</td><td align="left">The consensus mana information of online nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="onlinenodestr-1"><a class="header" href="#onlinenodestr-1"><code>OnlineNodeStr</code></a></h4>
<table><thead><tr><th align="left">Field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>rank</code></td><td align="left">int</td><td align="left">The rank of a node.</td></tr>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of consensus mana.</td></tr>
</tbody></table>
<h2 id="manaaccessnhighest"><a class="header" href="#manaaccessnhighest"><code>/mana/access/nhighest</code></a></h2>
<p>You can get the N highest access mana holders in the network, sorted in descending order.
If N=0, all nodes that have access mana are returned sorted.</p>
<h3 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-5"><a class="header" href="#examples-5">Examples</a></h3>
<h4 id="curl-5"><a class="header" href="#curl-5">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/access/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestaccessmana"><a class="header" href="#client-lib---getnhighestaccessmana">client lib - <code>GetNHighestAccessMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest access mana nodes
accessMana, err := goshimAPI.GetNHighestAccessMana(5)
if err != nil {
    // return error
}

for _, m := accessMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;access mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-5"><a class="header" href="#response-examples-5">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-5"><a class="header" href="#results-5">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest access mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-1"><a class="header" href="#mananodestr-1"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensusnhighest"><a class="header" href="#manaconsensusnhighest"><code>/mana/consensus/nhighest</code></a></h2>
<p>You can get the N highest consensus mana holders in the network, sorted in descending order.</p>
<h3 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>N</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The number of highest consensus mana nodes.</td></tr>
<tr><td><strong>Type</strong></td><td>int</td></tr>
</tbody></table>
<h3 id="examples-6"><a class="header" href="#examples-6">Examples</a></h3>
<h4 id="curl-6"><a class="header" href="#curl-6">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/nhighest?number=5 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getnhighestconsensusmana"><a class="header" href="#client-lib---getnhighestconsensusmana">client lib - <code>GetNHighestConsensusMana()</code></a></h4>
<pre><code class="language-go">// get the top 5 highest consensus mana nodes
consensusMana, err := goshimAPI.GetNHighestConsensusMana(5)
if err != nil {
    // return error
}

for _, m := consensusMana.Nodes {
    fmt.Println(&quot;full node ID: &quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}v
</code></pre>
<h3 id="response-examples-6"><a class="header" href="#response-examples-6">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;nodes&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-6"><a class="header" href="#results-6">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>nodes</code></td><td align="left">mana.NodeStr</td><td align="left">The N highest consensus mana nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-2"><a class="header" href="#mananodestr-2"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manapending"><a class="header" href="#manapending"><code>/mana/pending</code></a></h2>
<p>Get the amount of base access mana that would be pledged if the given output was spent.</p>
<h3 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>outputID</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The requesting output ID.</td></tr>
<tr><td><strong>Type</strong></td><td>string</td></tr>
</tbody></table>
<h3 id="examples-7"><a class="header" href="#examples-7">Examples</a></h3>
<h4 id="curl-7"><a class="header" href="#curl-7">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/pending?outputid=&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot; \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpending"><a class="header" href="#client-lib---getpending">client lib - <code>GetPending()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPending(&quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;)
if err != nil {
    // return error
}

// get the amount of mana
fmt.Println(&quot;mana be pledged: &quot;, res.Mana)
fmt.Println(&quot;the timestamp of the output (decay duration)&quot;, res.Timestamp)
</code></pre>
<h3 id="response-examples-7"><a class="header" href="#response-examples-7">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;mana&quot;: 26.5,
  &quot;outputID&quot;: &quot;4a5KkxVfsdFVbf1NBGeGTCjP8Ppsje4YFQg9bu5YGNMSJK1&quot;,  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-7"><a class="header" href="#results-7">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of access base mana to be pledged.</td></tr>
<tr><td align="left"><code>outputID</code></td><td align="left">string</td><td align="left">The output ID of the request.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h2 id="manaconsensuspast"><a class="header" href="#manaconsensuspast"><code>/mana/consensus/past</code></a></h2>
<p>Get the consensus base mana vector of a time (int64) in the past.</p>
<h3 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>timestamp</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>The timestamp of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>int64</td></tr>
</tbody></table>
<h3 id="examples-8"><a class="header" href="#examples-8">Examples</a></h3>
<h4 id="curl-8"><a class="header" href="#curl-8">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/past?timestamp=1614924295 \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getpastconsensusmanavector"><a class="header" href="#client-lib---getpastconsensusmanavector">client lib - <code>GetPastConsensusManaVector()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetPastConsensusManaVector(1614924295)
if err != nil {
    // return error
}

// the mana vector of each node
for _, m := range res.Consensus {
    fmt.Println(&quot;node ID:&quot;, m.NodeID, &quot;consensus mana: &quot;, m.Mana)
}
</code></pre>
<h3 id="response-examples-8"><a class="header" href="#response-examples-8">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;consensus&quot;: [
      {
        &quot;shortNodeID&quot;: &quot;4AeXyZ26e4G&quot;,
        &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
        &quot;mana&quot;: 26.5 
      }
  ],  
  &quot;timestamp&quot;: 1614924295
}
</code></pre>
<h3 id="results-8"><a class="header" href="#results-8">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>consensus</code></td><td align="left">mana.NodeStr</td><td align="left">The consensus mana of nodes.</td></tr>
<tr><td align="left"><code>timestamp</code></td><td align="left">int64</td><td align="left">The timestamp of mana updates.</td></tr>
</tbody></table>
<h4 id="mananodestr-3"><a class="header" href="#mananodestr-3"><code>mana.NodeStr</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>shortNodeID</code></td><td align="left">string</td><td align="left">The short ID of a node.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>mana</code></td><td align="left">float64</td><td align="left">The amount of mana.</td></tr>
</tbody></table>
<h2 id="manaconsensuslogs"><a class="header" href="#manaconsensuslogs"><code>/mana/consensus/logs</code></a></h2>
<p>Get the consensus event logs of the given node IDs.</p>
<h3 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>Parameter</strong></td><td><code>nodeIDs</code></td></tr>
<tr><td><strong>Required or Optional</strong></td><td>Required</td></tr>
<tr><td><strong>Description</strong></td><td>A list of node ID of the request.</td></tr>
<tr><td><strong>Type</strong></td><td>string array</td></tr>
</tbody></table>
<h3 id="examples-9"><a class="header" href="#examples-9">Examples</a></h3>
<h4 id="curl-9"><a class="header" href="#curl-9">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/mana/consensus/logs \
-X GET \
-H 'Content-Type: application/json'
-d '{
  &quot;nodeIDs&quot;: [
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
    &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux6&quot;
  ]
}'
</code></pre>
<h4 id="client-lib---getconsensuseventlogs"><a class="header" href="#client-lib---getconsensuseventlogs">client lib - <code>GetConsensusEventLogs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetConsensusEventLogs([]string{&quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;})
if err != nil {
    // return error
}

for nodeID, e := range res.Logs {
    fmt.Println(&quot;node ID:&quot;, nodeID)
    
    // pledge logs
    for _, p := e.Pledge {
        fmt.Println(&quot;mana type: &quot;, p.ManaType)
        fmt.Println(&quot;node ID: &quot;, p.NodeID)
        fmt.Println(&quot;time: &quot;, p.Time)
        fmt.Println(&quot;transaction ID: &quot;, p.TxID)
        fmt.Println(&quot;mana amount: &quot;, p.Amount)
    }

    // revoke logs
    for _, r := e.Revoke {
        fmt.Println(&quot;mana type: &quot;, r.ManaType)
        fmt.Println(&quot;node ID: &quot;, r.NodeID)
        fmt.Println(&quot;time: &quot;, r.Time)
        fmt.Println(&quot;transaction ID: &quot;, r.TxID)
        fmt.Println(&quot;mana amount: &quot;, r.Amount)
        fmt.Println(&quot;input ID: &quot;, r.InputID)
    }
}
</code></pre>
<h3 id="response-examples-9"><a class="header" href="#response-examples-9">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;logs&quot;: [
      &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;: {
          &quot;pledge&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28
               }
          ],
          &quot;revoke&quot;: [
              {
                  &quot;manaType&quot;: &quot;Consensus&quot;,
                  &quot;nodeID&quot;: &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;,
                  &quot;time&quot;: 1614924295,
                  &quot;txID&quot;: &quot;7oAfcEhodkfVyGyGrobBpRrjjdsftQknpj5KVBQjyrda&quot;,
                  &quot;amount&quot;: 28,
                  &quot;inputID&quot;: &quot;35P4cW9QfzHNjXJwZMDMCUxAR7F9mfm6FvPbdpJWudK2nBZ&quot;
              }
          ]
      }
  ],  
  &quot;startTime&quot;: 1614924295,
  &quot;endTime&quot;: 1614924300
}
</code></pre>
<h3 id="results-9"><a class="header" href="#results-9">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>logs</code></td><td align="left">map[string]*EventLogsJSON</td><td align="left">The consensus mana of nodes. The key of map is node ID.</td></tr>
<tr><td align="left"><code>startTime</code></td><td align="left">int64</td><td align="left">The starting time of collecting logs.</td></tr>
<tr><td align="left"><code>endTime</code></td><td align="left">int64</td><td align="left">The ending time of collecting logs.</td></tr>
</tbody></table>
<h4 id="eventlogsjson"><a class="header" href="#eventlogsjson"><code>EventLogsJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>pledge</code></td><td align="left">PledgedEventJSON</td><td align="left">Pledged event logs.</td></tr>
<tr><td align="left"><code>revoke</code></td><td align="left">RevokedEventJSON</td><td align="left">Revoked event logs.</td></tr>
</tbody></table>
<h4 id="pledgedeventjson"><a class="header" href="#pledgedeventjson"><code>PledgedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of pledged mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of pledged mana.</td></tr>
</tbody></table>
<h4 id="revokedeventjson"><a class="header" href="#revokedeventjson"><code>RevokedEventJSON</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>manaType</code></td><td align="left">string</td><td align="left">Type of mana.</td></tr>
<tr><td align="left"><code>nodeID</code></td><td align="left">string</td><td align="left">The full ID of a node.</td></tr>
<tr><td align="left"><code>time</code></td><td align="left">int64</td><td align="left">The time of transaction.</td></tr>
<tr><td align="left"><code>txID</code></td><td align="left">string</td><td align="left">The transaction ID of revoked mana.</td></tr>
<tr><td align="left"><code>amount</code></td><td align="left">float64</td><td align="left">The amount of revoked mana.</td></tr>
<tr><td align="left"><code>inputID</code></td><td align="left">string</td><td align="left">The input ID of revoked mana.</td></tr>
</tbody></table>
<h2 id="valueallowedmanapledge"><a class="header" href="#valueallowedmanapledge"><code>/value/allowedManaPledge</code></a></h2>
<p>This returns the list of allowed mana pledge node IDs.</p>
<h3 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h3>
<p>None.</p>
<h3 id="examples-10"><a class="header" href="#examples-10">Examples</a></h3>
<h4 id="curl-10"><a class="header" href="#curl-10">cURL</a></h4>
<pre><code class="language-shell">curl http://localhost:8080/value/allowedManaPledge \
-X GET \
-H 'Content-Type: application/json'
</code></pre>
<h4 id="client-lib---getallowedmanapledgenodeids"><a class="header" href="#client-lib---getallowedmanapledgenodeids">client lib - <code>GetAllowedManaPledgeNodeIDs()</code></a></h4>
<pre><code class="language-go">res, err := goshimAPI.GetAllowedManaPledgeNodeIDs()
if err != nil {
    // return error
}

// print the list of nodes that access mana is allowed to be pledged to
for _, id := range res.Access.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}

// print the list of nodes that consensus mana is allowed to be pledged to
for _, id := range res.Consensus.Allowed {
    fmt.Println(&quot;node ID:&quot;, id)
}
</code></pre>
<h3 id="response-examples-10"><a class="header" href="#response-examples-10">Response examples</a></h3>
<pre><code class="language-shell">{
  &quot;accessMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
  &quot;consensusMana&quot;: {
      &quot;isFilterEnabled&quot;: false,
      &quot;allowed&quot;: [
          &quot;2GtxMQD94KvDH1SJPJV7icxofkyV1njuUZKtsqKmtux5&quot;
      ] 
  }
}
</code></pre>
<h3 id="results-10"><a class="header" href="#results-10">Results</a></h3>
<table><thead><tr><th align="left">Return field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>accessMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge access mana.</td></tr>
<tr><td align="left"><code>consensusMana</code></td><td align="left">AllowedPledge</td><td align="left">A list of nodes that allow to pledge consensus mana.</td></tr>
</tbody></table>
<h4 id="allowedpledge"><a class="header" href="#allowedpledge"><code>AllowedPledge</code></a></h4>
<table><thead><tr><th align="left">field</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody>
<tr><td align="left"><code>isFilterEnabled</code></td><td align="left">bool</td><td align="left">A flag shows that if mana pledge filter is enabled.</td></tr>
<tr><td align="left"><code>allowed</code></td><td align="left">[]string</td><td align="left">A list of node ID that allow to be pledged mana.</td></tr>
</tbody></table>
<h1 id="tooling"><a class="header" href="#tooling">Tooling</a></h1>
<h1 id="docker-private-network"><a class="header" href="#docker-private-network">Docker private network</a></h1>
<p>We provide a tool at <code>tools/docker-network</code> with which a local test network can be set up locally with docker. </p>
<p><img src="tooling/../../images/docker-network.png" alt="Docker network" /></p>
<h2 id="how-to-use-the-tool"><a class="header" href="#how-to-use-the-tool">How to use the tool</a></h2>
<p>In the docker network run for example</p>
<pre><code>./run.sh 5 1
</code></pre>
<p>The command <code>./run.sh</code> spins up a GoShimmer network within Docker as schematically shown in the figure above. The first integer input defines the number of <code>peer_replicas</code> <code>N</code>. The second argument is optional for activating the Grafana dashboard, where </p>
<ul>
<li>default (no argument) or 0: Grafana disabled</li>
<li>1: Grafana enabled</li>
</ul>
<p>More details on how to set up the dashboard can be found <a href="https://github.com/iotaledger/goshimmer/wiki/Setup-up-a-GoShimmer-node-(Joining-the-pollen-testnet)#setting-up-the-grafana-dashboard">here</a>.</p>
<p>The peers can communicate freely within the Docker network 
while the analysis and visualizer dashboard, as well as the <code>master_peer's</code> dashboard and web API are reachable from the host system on the respective ports.</p>
<p>The settings for the different containers (<code>entry_node</code>, <code>peer_master</code>, <code>peer_replica</code>) can be modified in <code>docker-compose.yml</code>.</p>
<h2 id="how-to-use-as-development-tool"><a class="header" href="#how-to-use-as-development-tool">How to use as development tool</a></h2>
<p>Using a standalone throwaway Docker network can be really helpful as a development tool. </p>
<p>Prerequisites: </p>
<ul>
<li>Docker 17.12.0+</li>
<li>Docker compose: file format 3.5</li>
</ul>
<p>Reachable from the host system</p>
<ul>
<li>analysis dashboard (autopeering visualizer): http://localhost:9000</li>
<li><code>master_peer's</code> dashboard: http: http://localhost:8081</li>
<li><code>master_peer's</code> web API: http: http://localhost:8080</li>
</ul>
<p>It is therefore possible to send messages to the local network via the <code>master_peer</code>. Log messages of a specific containter can be followed via </p>
<pre><code>docker logs --follow CONTAINERNAME
</code></pre>
<h2 id="how-to-use-message-approval-check-tool"><a class="header" href="#how-to-use-message-approval-check-tool">How to use message approval check tool</a></h2>
<p><code>get_approval_csv.sh</code> script helps you conveniently trigger the message approval checks on all nodes in the docker
network, and gather their results in the <code>csv</code> folder.</p>
<p>Once the network is up and running, execute the script:</p>
<pre><code>./get_approval_csv.sh
</code></pre>
<p>Example output:</p>
<pre><code>Triggering approval analysis on peer_master and 20 replicas...
Triggering approval analysis on peer_master and 20 replicas... DONE
Copying csv files from peer_master and 20 replicas...
Copying csv files from peer_master and 20 replicas... DONE
Copied files are located at ./csv
</code></pre>
<p>The exported csv files are timestamped to the date of request.</p>
<pre><code>csv
├── 210120_16_34_14-docker-network_peer_replica_10.csv
├── 210120_16_34_14-docker-network_peer_replica_11.csv
├── 210120_16_34_14-docker-network_peer_replica_12.csv
...
</code></pre>
<p>Note, that the record length of the files might differ, since the approval check execution time of the nodes might differ.</p>
<h2 id="spammer-tool"><a class="header" href="#spammer-tool">Spammer tool</a></h2>
<p>The Spammer tool lets you add messages to the tangle when running GoShimmer in a Docker network.
In order to start the spammer, you need to send GET requests to a <code>/spammer</code> API endpoint with the following parameters:</p>
<ul>
<li><code>cmd</code> - one of two possible values: <code>start</code> and <code>shutdown</code>.</li>
<li><code>mpm</code> - messages per minute. Only applicable when <code>cmd=start</code>. </li>
<li><code>imif</code> - (<em>optional</em>) parameter indicating time interval between issued messages. Possible values:
<ul>
<li><code>poisson</code> - emit messages modeled with Poisson point process, whose time intervals are exponential variables with mean 1/rate</li>
<li><code>uniform</code> - issues messages at constant rate</li>
</ul>
</li>
</ul>
<p>Example requests:</p>
<pre><code class="language-bash">http://localhost:8080/spammer?cmd=start&amp;mpm=1000

http://localhost:8080/spammer?cmd=start&amp;mpm=1000&amp;imif=uniform
http://localhost:8080/spammer?cmd=shutdown
</code></pre>
<h2 id="tangle-width"><a class="header" href="#tangle-width">Tangle width</a></h2>
<p>When running GoShimmer locally in a Docker network, the network delay is so small that only 1 tip will be available most of the time. 
In order to artificially create a tangle structure with multiple tips you can add a <code>messageLayer.tangleWidth</code> property to <a href="tooling/tools/docker-network/config.docker.json">config.docker.json</a>
that specifies the number of tips that nodes should retain. This setting exists only for local testing purposes and should not be used in a distributed testnet.</p>
<p>Here is an example config that can be added: </p>
<pre><code class="language-json">  &quot;messageLayer&quot;: {
    &quot;tangleWidth&quot;: 10
  },
</code></pre>
<h1 id="specification"><a class="header" href="#specification">Specification</a></h1>
<h1 id="mana-implementation-proposal"><a class="header" href="#mana-implementation-proposal">Mana Implementation Proposal</a></h1>
<p>The goal of this document is to provide a high level overview of how mana will be implemented in GoShimmer.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Mana is a reputation system for nodes within the IOTA network.</p>
<p>Reputation is gained by contributing to the network, i.e. creating value transfers.
As time passes, part of the earned mana of a node decays to encourage keeping up the good behavior.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>The scope of the first implementation of mana into GoShimmer is to verify that mana calculations work,
study base mana calculations 1 &amp; 2, and mana distribution in the test network, furthermore to verify that nodes have
similar view on the network.</p>
<h2 id="mana-calculation"><a class="header" href="#mana-calculation">Mana Calculation</a></h2>
<p>Mana is essentially the reputation score of a node in the IOTA network. Mana is calculated locally in each node, as a
function that takes value transactions as input and produces the Base Mana Vector as output.</p>
<p>Each transaction has an <code>accessMana</code> and <code>consensusMana</code> field that determine which node to pledge these two types
of mana to. Both of these fields denote a <code>nodeID</code>, the receiver of mana. <code>accessMana</code> and <code>consensusMana</code> do not have
to be pledged to the same node, but for simplicity, in the first implementation, they will be.</p>
<p>In addition to the mana fields, a <code>timestamp</code> field is also added to the transactions that will be utilized for calculating
decay and effective mana.</p>
<p>From the pledged mana of a transaction, a node can calculate locally the <code>Base Mana Vector</code> for both <code>Access Mana</code> and
<code>Consensus Mana</code>.</p>
<p>A <code>Base Mana Vector</code> consists of Base Mana 1 and Base Mana 2 and their respective <code>Effective Base Mana</code>.
Given a value transaction, Base Mana 1 and Base Mana 2 are determined as follows:</p>
<ol>
<li>Base Mana 1 is revoked from the node that created the output(s) used as input(s) in the transaction, and is pledged to
the node creating the new output(s). The amount of <code>Base Mana 1</code> revoked and pledged is equal to the balance of the
input.</li>
<li>Base Mana 2 is freshly created at the issuance time of the transaction, awarded to the node, but decays with time.
The amount of <code>Base Mana 2</code> pledged is determined with <code>Pending Mana</code> concept: funds sitting at an address generate
<code>pending mana</code> that grows over time, but bounded.
<ul>
<li><code>Mana_pending = (alpha*S)/gamma*(1-e^(-gamma*t))</code>, where <code>alpha</code> and <code>gamma</code> are chosen parameters, <code>S</code> is the amount
of funds an output transfers to the address, and <code>t</code> is the time since the funds are on that address.</li>
</ul>
</li>
</ol>
<p>An example <code>Base Mana Vector</code> for <code>Access Mana</code> could look like this:</p>
<p>| 		    | Node 1 | Node 2 | ... | Node k
|  ------- | --------- | ---------- | ------ | ---
| Base Mana 1 			|0	| 1 	|...|  100.54
| Effective Base Mana 1	|0	| 0.5 	|...|  120.7
| Base Mana 2 			|0	| 1.2	|...|  0.01
| Effective Base Mana 2	|0	| 0.6 	|...|  0.015</p>
<p><code>Base Mana</code> is pledged or revoked at discrete times, which results in <code>Base Mana</code> being discontinuous function over time.
In order to make mana &quot;smoother&quot; and continuous, an exponential moving average is applied to the <code>Base Mana</code> values,
resulting in <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code>.</p>
<p>It is important to note, that consuming a new transaction and pledging its mana happens when the transaction is
confirmed on the node. At the same time, entries of the nodes whose mana is being modified during pledging in the
<code>Base Mana Vector(s)</code> are updated with respect to time. In general, updates due to time happen whenever a node's mana is
being accessed. Except for the aforementioned case, this could be for example a mana related query from an external
module (FPC, Autopeering, DRNG, Rate Control, tools, etc.).</p>
<p>Following figure summarizes how <code>Access Mana</code> and <code>Consensus Mana</code> is derived from a transaction:</p>
<p><img src="https://i.imgur.com/LjfCTm9.png" alt="" /></p>
<p>The reason for having two separate <code>Base Mana Vectors</code> is the fact, that <code>accessMana</code> and <code>consensusMana</code> can be pledged
to different nodes.</p>
<p>The exact mathematical formulas, and their respective parameters will be determined later.</p>
<h2 id="challenges"><a class="header" href="#challenges">Challenges</a></h2>
<h3 id="dependency-on-tangle"><a class="header" href="#dependency-on-tangle">Dependency on Tangle</a></h3>
<p>Since mana is awarded to nodes submitting value transfers, the tangle is needed as input for mana calculation.
Each node calculates mana locally, therefore, it is essential to determine when to consider transactions in the
tangle &quot;final enough&quot; (so that they will not be orphaned).</p>
<p>When a transaction is <code>confirmed</code>, it is a sufficient indicator that it will not be orphaned. However, in current
GoShimmer implementation, confirmation is not yet a properly defined concept. This issue will be addressed in a separate
module.</p>
<p>The Mana module assumes, that the (value) tangle's <code>TransactionConfirmed</code> event is the trigger condition to update the
mana state machine (base mana vectors for access and consensus mana). Once the concept of transaction finality is
introduced for the tangle, the trigger conditions for access and consensus mana calculations can be adjusted.</p>
<h3 id="transaction-layout"><a class="header" href="#transaction-layout">Transaction Layout</a></h3>
<p>A new field should be added to <code>Transaction</code> denoting <code>PledgedNodeID</code> for <code>Access Mana</code> and <code>Consensus Mana</code>.
This is also beneficial to implement mana donation feature, that is, to donate the mana of a certain transaction to an
arbitrary node.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>The first implementation of mana in GoShimmer will:</p>
<ul>
<li>not have voted timestamps on value transactions,</li>
<li>lack proper <code>TransactionConfirmed</code> mechanism to trigger mana update,</li>
<li>lack integration into rate control/autopeering/fpc/etc.</li>
</ul>
<h2 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h2>
<p>In this section, detailed GoShimmer implementation design considerations will be outlined about the mana module.
In short, changes can be classified into 3 categories:</p>
<ol>
<li>Transaction related changes,</li>
<li>Mana module functionality,</li>
<li>and related tools/utilities, such as API, visualization, analytics.</li>
</ol>
<h3 id="transaction"><a class="header" href="#transaction">Transaction</a></h3>
<p>As described above, 3 new fields will be added to the transaction layout:</p>
<ol>
<li><code>Timestamp</code> time.time</li>
<li><code>AccessManaNodeID</code> []bytes</li>
<li><code>ConsensusManaNodeID</code> []bytes</li>
</ol>
<p>By adding these fields to the signed transaction, <code>valuetransfers/packages/transaction</code> should be modified.</p>
<ul>
<li>The three new fields should be added to the transaction essence.</li>
<li>Marshalling and unmarshalling of a transaction should be modified.</li>
<li>For calculating <code>Base Mana 1</code> values, <code>mana module</code> should be able to derive from a transaction the nodes which received
pledged <code>Base Mana 1</code> as a consequence of the consumed inputs of the transaction. Therefore, a lookup function should
be exposed from the value tangle that given an <code>input</code>, returns the <code>pledgedNodeID</code> of the transaction creating the input.</li>
</ul>
<p><code>Timestamp</code> is part of the signed transaction, therefore, a client sending a transaction to the node should already
define it. In this case, this <code>Timestamp</code> will not be the same as the timestamp of the message containing the
transaction and value payload, since the message is created on the node.
A solution to this is that upon receiving a <code>transaction</code> from a client, the node checks if the timestamp is within
a predefined time window, for example <code>t_current - delta</code>, where <code>delta</code> could be couple seconds. If true, then the node
constructs the message, which must have a greater timestamp, than the transaction.</p>
<p><code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are also part of the signed transaction, so a client should fill them out.
Node owners are free to choose to whom they pledge mana to with the transaction, so there should be a mechanism that
lets the client know, what <code>AccessManaNodeID</code> and <code>ConsensusManaNodeID</code> are allowed. This could be a new API endpoint
that works like this:</p>
<ol>
<li>Client asks node what nodeIDs can be included for pledging  a certain type (access, consensus) mana.</li>
<li>Node answers with either:</li>
</ol>
<ul>
<li>Don't care. Any node IDs are valid.</li>
<li>List of nodeIDs that are allowed for each type.</li>
</ul>
<ol start="3">
<li>If a client sends back the transaction with invalid or empty mana fields, the transaction is considered invalid.</li>
</ol>
<p>This way node owners can decide who their transactions are pledging mana to. It could be only their node, or they could
provide mana pledging as a service. They could delegate access mana to others, but hold own to consensus mana, or the
other way around.</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>Mana state machine is an extension of the ledger state, hence its calculation depends on the ledger state perception
of the node. Snapshotting is the mechanism that saves the ledger states and prunes unnecessary transactions. Together
with the ledger state, base mana vectors are also saved, since a certain ledger state reflects a certain mana distribution
in the network. In future, when snapshotting is implemented in GoShimmer, nodes joining the network will be able to query
for snapshot files that will contain initial base mana vectors as well.</p>
<p>Until this functionality is implemented, mana calculation solely relies on transactions getting confirmed. That is, when
a node joins the network and starts gathering messages and transactions from peers, it builds its own ledger state through
solidification process. Essentially, the node requests all messages down to the genesis from the current tips of its neighbors.
Once the genesis is found, messages are solidified bottom up. For the value tangle, this means that for each solidified
and liked transaction, <code>TransactionConfirmed</code> event is triggered, updating the base mana vectors.</p>
<p>In case of a large database, initial synching and solidification is a computationally heavy task due to the sheer amount
of messages in the tangle. Mana calculation only adds to this burden. It will be determined through testing if additional
&quot;weight lifting&quot; mechanism is needed (for example delaying mana calculation).</p>
<p>In Pollen test network, all funds are initially held by the faucet node, therefore all mana present at bootstrap belong
to this node. Whenever a transaction is requested from the faucet, it pledges mana to the requesting node, helping other
nodes to increase their mana.</p>
<h3 id="mana-package"><a class="header" href="#mana-package">Mana Package</a></h3>
<p>The functionality of the mana module should be implemented in a <code>mana</code> package. Then, a <code>mana plugin</code> can use the package
structs and methods to connect the dots, for example execute <code>BookMana</code> when <code>TransactionConfirmed</code> event is triggered
in the value tangle.</p>
<p><code>BaseMana</code> is a struct that holds the different mana values for a given node.
Note that except for <code>Base Mana 1</code> calculation, we need the time when <code>BaseMana</code> values were updated, so we store it in the struct:</p>
<pre><code class="language-go">type BaseMana struct {
 BaseMana1 float
 EffectiveBaseMana1 float
 BaseMana2 float
 EffectiveBaseMana2 float
 LastUpdated time
}
</code></pre>
<p><code>BaseManaVector</code> is a data structure that maps <code>nodeID</code>s to <code>BaseMana</code>. It also has a <code>Type</code> that denotes the type
of mana this vector deals with (Access, Consensus, etc.).</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<p><code>BaseManaVector</code> should have the following methods:</p>
<ul>
<li><code>BookMana(transaction)</code>: Book mana of a transaction. Trigger <code>ManaBooked</code> event. Note, that this method updates
<code>BaseMana</code> with respect to time and to new <code>Base Mana 1</code> and <code>Base Mana 2</code> values.</li>
<li><code>GetWeightedMana(nodeID, weight) mana</code>: Return <code>weight</code> *<code> Effective Base Mana 1</code> + (1-<code>weight</code>)+<code>Effective Base Mana 2</code>.
<code>weight</code> is a number in [0,1] interval. Notice, that <code>weight</code> = 1  results in only returning <code>Effective Base Mana 1</code>,
and the other way around. Note, that this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>GetMana(nodeID) mana</code>: Return 0.5*<code>Effective Base Mana 1</code> + 0.5*<code>Effective Base Mana 2</code> of a particular node. Note, that
this method also updates <code>BaseMana</code> of the node with respect to time.</li>
<li><code>update(nodeID, time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of a node with respect <code>time</code>.</li>
<li><code>updateAll(time)</code>: update <code>Base Mana 2</code>, <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> of all nodes with respect to <code>time</code>.</li>
</ul>
<p><code>BaseMana</code> should have the following methods:</p>
<ul>
<li><code>pledgeAndUpdate(transaction)</code>: update <code>BaseMana</code> fields and pledge mana with respect to <code>transaction</code>.</li>
<li><code>revokeBaseMana1(amount, time)</code>:  update <code>BaseMana</code> values with respect to <code>time</code> and revoke <code>amount</code> <code>BaseMana1</code>.</li>
<li><code>update(time)</code>: update all <code>BaseMana</code> fields with respect to <code>time</code>.</li>
<li><code>updateEBM1(time)</code>: update <code>Effective Base Mana 1</code> wrt to <code>time</code>.</li>
<li><code>updateBM2(time)</code>: update <code>Base Mana 2</code> wrt to <code>time</code>.</li>
<li><code>updateEBM2(time)</code>: update <code>Effective Base Mana 2</code> wrt to <code>time</code>.</li>
</ul>
<h4 id="base-mana-calculation"><a class="header" href="#base-mana-calculation">Base Mana Calculation</a></h4>
<p>There are two cases when the values within <code>Base Mana Vector</code> are updated:</p>
<ol>
<li>A confirmed transaction pledges mana.</li>
<li>Any module accesses the <code>Base Mana Vector</code>, and hence its values are updated with respect to <code>access time</code>.</li>
</ol>
<p>First, let's explore the former.</p>
<h5 id="a-confirmed-transaction-pledges-mana"><a class="header" href="#a-confirmed-transaction-pledges-mana">A confirmed transaction pledges mana</a></h5>
<p>For simplicity, we only describe mana calculation for one of the Base Mana Vectors, namely, the Base Access Mana Vector.</p>
<p>First, a <code>TransactionConfirmed</code> event is triggered, therefore <code>BaseManaVector.BookMana(transaction)</code> is executed:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) BookMana(tx *transaction) {
    pledgedNodeID := tx.accessMana

    for input := range tx.inputs {
        // search for the nodeID that the input's tx pledged its mana to
        inputNodeID := loadPledgedNodeIDFromInput(input)
        // save it for proper event trigger
        oldMana := bmv[inputNodeID]
        // revoke BM1
        bmv[inputNodeID].revokeBaseMana1(input.balance, tx.timestamp)

        // trigger events
        Events.ManaRevoked.Trigger(&amp;ManaRevokedEvent{inputNodeID, input.balance, tx.timestamp, AccessManaType})
        Events.ManaUpdated.Tigger(&amp;ManaUpdatedEvent{inputNodeID, oldMana, bmv[inputNodeID], AccessManaType})
    }

    // save it for proper event trigger
    oldMana :=  bmv[pledgedNodeID]
    // actually pledge and update
    bm1Pledged, bm2Pledged := bmv[pledgedNodeID].pledgeAndUpdate(tx)

    // trigger events
    Events.ManaPledged.Trigger(&amp;ManaPledgedEvent{pledgedNodeID, bm1Pledged, bm2Pledged, tx.timestamp, AccessManaType})
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{pledgedNodeID, oldMana, bmv[pledgedNodeID], AccessManaType})
}
</code></pre>
<p><code>Base Mana 1</code> is being revoked from the nodes that pledged mana for inputs that the current transaction consumes.
Then, the appropriate node is located in <code>Base Mana Vector</code>, and mana is pledged to its <code>BaseMana</code>.
<code>Events</code> are essential to study what happens within the module from the outside.</p>
<p>Note, that <code>revokeBaseMana1</code> accesses the mana entry of the nodes within <code>Base Mana Vector</code>, therefore all values are
updated with respect to <code>t</code>. Notice the two branches after the condition. When <code>Base Mana</code> values had been updated before
the transaction's timestamp, a regular update is carried out. However, if <code>t</code> is older, than the transaction timestamp,
an update in the &quot;past&quot; is carried out and values are updated up to <code>LastUpdated</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) revokeBaseMana1(amount float64, t time.Time) {
	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)

		bm.LastUpdated = t
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
	} else {
		// update in past
		n := bm.LastUpdated.Sub(t)
		// revoke BM1 at `t`
		bm.BaseMana1 -= amount
		// update EBM1 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 -= amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
	}
}
</code></pre>
<p>The same regular and past update scheme is applied to pledging mana too:</p>
<pre><code class="language-go">func (bm *BaseMana) pledgeAndUpdate(tx *transaction) (bm1Pledged int, bm2Pledged int){
	t := tx.timestamp
	bm1Pledged = sum_balance(tx.inputs)

	if t.After(bm.LastUpdated) {
		// regular update
		n := t.Sub(bm.LastUpdated)
		// first, update EBM1, BM2 and EBM2 until `t`
		bm.updateEBM1(n)
		bm.updateBM2(n)
		bm.updateEBM2(n)
		bm.LastUpdated = t
		bm.BaseMana1 += bm1Pledged
		// pending mana awarded, need to see how long funds sat
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1 - math.Pow(math.E, -decay*(t-t_inp)))
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
	} else {
		// past update
		n := bm.LastUpdated.Sub(t)
		// update BM1 and BM2 at `t`
		bm.BaseMana1 += bm1Pledged
		oldMana2 = bm.BaseMana2
		for input := range tx.inputs {
			// search for the timestamp of the UTXO that generated the input
			t_inp := LoadTxTimestampFromOutputID(input)
			bm2Add := input.balance * (1-math.Pow( math.E,-decay*(t-t_inp) ) ) * math.Pow(math.E, -decay*n)
			bm.BaseMana2 += bm2Add
			bm2Pledged += bm2Add
		}
		// update EBM1 and EBM2 to `bm.LastUpdated`
		bm.EffectiveBaseMana1 += amount*(1-math.Pow(math.E,-EMA_coeff_1*n))
		if EMA_coeff_2 != decay {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) *EMA_coeff_2*(math.Pow(math.E,-decay*n)-
                math.Pow(math.E,-EMA_coeff_2*n))/(EMA_coeff_2-decay) / math.Pow(math.E, -decay*n)
		} else {
			bm.EffectiveBaseMana2 += (bm.BaseMana2 - oldMana2) * decay * n
		}
}
	return bm1Pledged, bm2Pledged
}
</code></pre>
<p>Notice, that in case of <code>EMA_coeff_2 = decay</code>, a simplified formula can be used to calculate <code>EffectiveBaseMana2</code>.
The same approach is applied in <code>updateEBM2()</code>.</p>
<pre><code class="language-go">func (bm *BaseMana) updateEBM1(n time.Duration) {
    bm.EffectiveBaseMana1 = math.Pow(math.E, -EMA_coeff_1 * n) * bm.EffectiveBaseMana1 +
                                 (1-math.Pow(math.E, -EMA_coeff_1 * n)) * bm.BaseMana1
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateBM2(n time.Duration) {
    bm.BaseMana2 = bm.BaseMana2 * math.Pow(math.E, -decay*n)
}
</code></pre>
<pre><code class="language-go">func (bm *BaseMana) updateEBM2(n time.Duration) {
	if EMA_coeff_2 != decay {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -emaCoeff2 * n) * bm.EffectiveBaseMana2 +
			(math.Pow(math.E, -decay * n) - math.Pow(math.E, -EMA_coeff_2 * n)) /
				(EMA_coeff_2 - decay) * EMA_coeff_2 / math.Pow(math.E, -decay * n)*bm.BaseMana2
	} else {
		bm.EffectiveBaseMana2 = math.Pow(math.E, -decay * n)*bm.EffectiveBaseMana2 +
			decay * n * bm.BaseMana2
	}
}
</code></pre>
<h5 id="any-module-accesses-the-base-mana-vector"><a class="header" href="#any-module-accesses-the-base-mana-vector">Any module accesses the Base Mana Vector</a></h5>
<p>In this case, the accessed entries within <code>Base Mana Vector</code> are updated via the method:</p>
<pre><code class="language-go">func (bmv *BaseManaVector) update(nodeID ID, t time.Time ) {
    oldMana :=  bmv[nodeID]
    bmv[nodeID].update(t)
    Events.ManaUpdated.Trigger(&amp;ManaUpdatedEvent{nodeID, oldMana, bmv[nodeID], AccessManaType})
}
</code></pre>
<p>where <code>t</code> is the access time.</p>
<pre><code class="language-go">func (bm *BaseMana) update(t time.Time ) {
    n := t - bm.LastUpdated
    bm.updateEBM1(n)
    bm.updateBM2(n)
    bm.updateEBM2(n)

    bm.LastUpdated = t
}
</code></pre>
<h4 id="events"><a class="header" href="#events">Events</a></h4>
<p>The mana package should have the following events:</p>
<ul>
<li><code>Pledged</code> when mana (<code>BM1</code> and <code>BM2</code>) was pledged for a node due to new transactions being confirmed.</li>
</ul>
<pre><code class="language-go">type PledgedEvent struct {
    NodeID []bytes
    AmountBM1 int
    AmountBM2 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Revoked</code> when mana (<code>BM1</code>) was revoked from a node.</li>
</ul>
<pre><code class="language-go">type RevokedEvent struct {
    NodeID []bytes
    AmountBM1 int
    Time time.Time
    Type ManaType // access or consensus
}
</code></pre>
<ul>
<li><code>Updated</code> when mana was updated for a node due to it being accessed.</li>
</ul>
<pre><code class="language-go">type UpdatedEvent struct {
    NodeID []bytes
    OldMana BaseMana
    NewMana BaseMana
    Type    ManaType // access or consensus
}
</code></pre>
<h4 id="testing"><a class="header" href="#testing">Testing</a></h4>
<ul>
<li>Write unit tests for all methods.</li>
<li>Test all events and if they are correctly triggered.</li>
<li>Benchmark calculations in tests to see how heavy it is to calculate EMAs and decays.</li>
</ul>
<h3 id="mana-plugin"><a class="header" href="#mana-plugin">Mana Plugin</a></h3>
<p>The <code>mana plugin</code> is responsible for:</p>
<ul>
<li>calculating mana from value transactions,</li>
<li>keeping a log of the different mana values of all nodes,</li>
<li>updating mana values,</li>
<li>responding to mana related queries from other modules,</li>
<li>saving base mana vectors in database when shutting down the node,</li>
<li>trying to load base mana vectors from database when starting the node.</li>
</ul>
<p>The proposed mana plugin should keep track of the different mana values of nodes and handle calculation
updates. Mana values are mapped to <code>nodeID</code>s and stored in a <code>map</code> data structure. The vector also stores information on
what <code>Type</code> of mana it handles.</p>
<pre><code class="language-go">type BaseManaVector struct {
	vector     map[identity.ID]*BaseMana
	vectorType Type
}
</code></pre>
<p><code>Access Mana</code> and <code>Consensus Mana</code> should have their own respective <code>BaseManaVector</code>.</p>
<pre><code class="language-go">accessManaVector := BaseManaVector{vectorType: AccesMana}
consensusManaVector :=  BaseManaVector{vectorType: ConsensusMana}
</code></pre>
<p>In the future, it should be possible to combine <code>Effective Base Mana 1</code> and <code>Effective Base Mana 2</code> from a <code>BaseManaVector</code>
in arbitrary proportions to arrive at a final mana value that other modules use. The <code>mana package</code> has these methods
in place. Additionally, a parameter could be passed to the <code>getMana</code> type of exposed functions to set the proportions.</p>
<h4 id="methods-1"><a class="header" href="#methods-1">Methods</a></h4>
<p>The mana plugin should expose utility functions to other modules:</p>
<ul>
<li><code>GetHighestManaNodes(type, n) [n]NodeIdManaTuple</code>: return the <code>n</code> highest <code>type</code> mana nodes (<code>nodeID</code>,<code>manaValue</code>) in
ascending order. Should also update their mana value.</li>
<li><code>GetManaMap(type) map[nodeID]manaValue</code>: return <code>type</code> mana perception of the node.</li>
<li><code>GetAccessMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Access Mana</code>, update its values with respect to time,
and return the amount of <code>Access Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetConsensusMana(nodeID) mana</code>: access <code>Base Mana Vector</code> of <code>Consensus Mana</code>, update its values with respect to time,
and returns the amount of <code>Consensus Mana</code> (either <code>Effective Base Mana 1</code>, <code>Effective Base Mana 2</code>, or some combination
of the two). Trigger <code>ManaUpdated</code> event.</li>
<li><code>GetNeighborsMana(type)</code>: returns the <code>type</code> mana of the nodes neighbors</li>
<li><code>GetAllManaVectors()</code> Obtaining the full mana maps for comparison with the perception of other nodes.</li>
<li><code>GetWeightedRandomNodes(n)</code>: returns a weighted random selection of <code>n</code> nodes. <code>Consensus Mana</code> is used for the weights.</li>
<li>Obtaining a list of currently known peers + their mana, sorted. Useful for knowing which high mana nodes are online.</li>
<li><code>OverrideMana(nodeID, baseManaVector)</code>: Sets the nodes mana to a specific value. Can be useful for debugging, setting faucet mana, initialization, etc.. Triggers <code>ManaUpdated</code></li>
</ul>
<p>Such utility functions could be used for example to visualize mana distribution in node dashboard, or send neighbor
mana data to the analysis server for further processing.</p>
<h4 id="booking-mana"><a class="header" href="#booking-mana">Booking Mana</a></h4>
<p>Mana is booked when a transaction is confirmed.</p>
<pre><code class="language-go">on TransactionConfirmed (tx):
 bookAccessMana()
 bookConsensusMana()
</code></pre>
<h4 id="synchronization-and-mana-calculation"><a class="header" href="#synchronization-and-mana-calculation">Synchronization and Mana Calculation</a></h4>
<p>The mana plugin is responsible to determine when to start calculating mana locally.
Since mana state is an extension to ledger state, it can only depict realistic mana values once the node is in sync.
During syncing, ledger state is constructed from messages coming from neighbors as described further above.</p>
<p>In this first iteration, mana plugin relies on <code>TransactionConfirmed</code> event of the value transfers plugin, and has no
explicit rules on when to start and stop mana calculation.</p>
<p>In future, initial mana state (together with the initial ledger state) will be derived from a snapshot file.</p>
<h3 id="mana-toolkit"><a class="header" href="#mana-toolkit">Mana Toolkit</a></h3>
<p>In this section, all tools and utility functions for mana will be outlined.</p>
<h4 id="mana-related-api-endpoints"><a class="header" href="#mana-related-api-endpoints">Mana Related API endpoints</a></h4>
<ul>
<li><code>/info</code>: Add own mana in node info response.</li>
<li><code>value/allowedManaPledge</code>: Endpoint that clients can query to determine which nodeIDs are allowed as part of
<code>accessMana</code> and <code>consensusMana</code> fields in a transaction.</li>
<li><code>value/sendTransactionByJson</code>: Add <code>accessMana</code>, <code>consensusMana</code> and <code>timestamp</code> fields to the JSON request.</li>
</ul>
<p>Add a new <code>mana</code> endpoint route:</p>
<ul>
<li><code>/mana</code>: Return access and consensus mana of the node.</li>
<li><code>/mana/all</code>: Return whole mana map (mana perception of the node).</li>
<li><code>/mana/access/nhighest</code>: Return <code>n</code> highest access mana holder <code>nodeIDs</code> and their access mana values.</li>
<li><code>/mana/consensus/nhighest</code>: Return <code>n</code> highest consensus mana holder <code>nodeIDs</code> and their consensus mana values.</li>
<li><code>/mana/percentile</code>: Return the top percentile the node belongs to relative to the network. For example, if there are 100 nodes in the
network owning mana, and a node is the 13th richest, it means that is part of the top 13% of mana holders, but not the
top 12%.</li>
</ul>
<h4 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics collection</a></h4>
<p>To study the mana module, following metrics could be gathered:</p>
<ul>
<li>Amount of consensus and access mana present in the network. (amount varies because of <code>Base Mana 2</code>).</li>
<li>Amount of mana each node holds.</li>
<li>Number of (and amount of mana) a node was pledged with mana in the last <code>t</code> interval.</li>
<li>Mana development of a particular node over time.</li>
<li>Mana percentile development of a node over time.</li>
<li>Average pledge amount of a node. (how much mana it receives on average with one pledge)</li>
<li>Mean and median mana holdings of nodes in the network. Shows how even mana distribution is.</li>
<li>Average mana of neighbors.</li>
</ul>
<h4 id="visualization"><a class="header" href="#visualization">Visualization</a></h4>
<p>Each node calculates mana locally, not only for themselves, but for all nodes in the network that it knows. As a result,
mana perception of nodes may not be exactly the same at all times (due to network delay, processing capabilities), but
should converge to the same state. A big question for visualization is which node's viewpoint to base mana visualization on? </p>
<p>When running a node, operators will be shown the mana perception of their own node, but it also makes sense to
display the perception of high mana nodes as the global mana perception. First, let's look at how local mana perception
is visualized for a node:</p>
<h5 id="local-perception"><a class="header" href="#local-perception">Local Perception</a></h5>
<p>There are two ways to visualize mana in GoShimmer:</p>
<ol>
<li>Node Local Dashboard</li>
<li>Grafana Dashboard</li>
</ol>
<p>While <code>Local Dashboard</code> gives flexibility in what and how to visualize, <code>Grafana Dashboard</code> is better at storing historic
data but can only visualize time series. Therefore, both of these ways will be utilized, depending on which suits the best.</p>
<p><code>Local Dashboard</code> visualization:</p>
<ul>
<li>Histogram of mana distribution within the network.</li>
<li>List of <code>n</code> richest mana nodes, ordered.</li>
<li>Mana rank of node.</li>
</ul>
<p><code>Grafana Dashboard</code> visualization:</p>
<ul>
<li>Mana of a particular node with respect to time.</li>
<li>Amount of mana in the network.</li>
<li>Average pledge amount of a node.</li>
<li>Mean and median mana holdings of nodes.</li>
<li>Mana rank of the node over time.</li>
<li>Average mana of neighbors.</li>
</ul>
<h5 id="global-perception"><a class="header" href="#global-perception">Global Perception</a></h5>
<p>Additionally, the Pollen Analyzer (analysis server) could be updated:</p>
<ul>
<li>Autopeering node graph, where size of a node corresponds to its mana value.</li>
<li>Some previously described metrics could be visualized here as well, to give the chance to people without
a node to take a look. As an input, a high mana node's perception should be used.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
